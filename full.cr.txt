====================
FILE: Client.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import request.*;
import shared.Screen;


@Log4j2
@Getter
@Setter
public class Client {
    private ClientConnection connection;
    private BufferedReader userInput;
    private Gson gson;

    public static void main(String[] args) {
        Client client = new Client();
        client.handleServerCommunication();
    }

    public Client() {
        connection = new ClientConnection();
        gson = new Gson();
        userInput = new BufferedReader(new InputStreamReader(System.in));
    }

    public void handleServerCommunication() {
        try {
            log.info("Starting server communication");
            while(connection.isConnected()){
                printClientUI();
                String request = userInput.readLine();
                if (request == null || request.equalsIgnoreCase("EXIT")) {
                    connection.disconnect();
                    return;
                }
                    handleRequest(request);
            }
        } catch (IOException ex) {
            log.error("Error in handling server communication: {}", ex.getMessage());
        }
    }

    public void handleRequest(String request) throws IOException {
        log.info("Handling user request: {}", request);
        try{
            RequestFactory factory = new RequestFactory(connection);
            Request requestType = factory.getRequest(request);

            if (requestType != null) {
                String jsonRequest = gson.toJson(requestType);
                connection.sendRequest(jsonRequest);
                log.info("User attempted to {}", request);
                connection.readResponse();
            } else {
                System.out.println("Incorrect input. Please, try again");
            }
        } catch (IOException ex){
            log.error("Error handling request: {}", ex.getMessage());
        }
    }

    public void printClientUI(){
        if(!connection.isLoggedIn()) {
            Screen.printLoginMenu();
        } else {
            if(connection.isUserAuthorized()){
                Screen.printAdminMailBoxMenu();
            } else{
                Screen.printUserMailBoxMenu();
            }
        }
    }
}

====================
FILE: ClientConnection.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import shared.ResponseStatus;
import shared.JsonConverter;

@Log4j2
@Getter
@Setter
public class ClientConnection {
    private final int PORT_NUMBER = 5000;
    private Socket clientSocket;
    private PrintWriter outToServer;
    private BufferedReader inFromServer;
    public static boolean loggedIn = false;
    private boolean isAuthorized = false;
    public static int connectionAttempts = 0;
    private boolean connected = false;


    public ClientConnection() {
        connectToServer();

    }

    public void connectToServer() {
        try {
            clientSocket = new Socket("localhost", PORT_NUMBER);
            outToServer = new PrintWriter(clientSocket.getOutputStream(), true);
            inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            connected = true;
            log.info("Connection with Server established on port {}", PORT_NUMBER);
        } catch (IOException ex) {
            log.error("Failed to establish connection with the server at port {}. Error: {}", PORT_NUMBER, ex.getMessage());
            retryConnection();
        }
    }

    public void retryConnection() {
        if (connectionAttempts >= 2) {
            log.error("Max reconnection attempts reached. Giving up");
            disconnect();
            return;
        }
        try {
            Thread.sleep(2000);
            log.info("Attempting to reconnect to the server...");
            Thread.sleep(5000);
            connectionAttempts++;
            connectToServer();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            log.warn("Reconnection attempt interrupted", ie);
        }
    }

    public void sendRequest(String request) {
        outToServer.println(request);
        log.info("Sent request to server: {}", request);
    }

    public void readResponse() throws IOException {
        try{
            String jsonResponse;
            log.info("Reading response from server");
            while (!(jsonResponse = inFromServer.readLine()).equals("<<END>>")) {
                String response = JsonConverter.deserializeMessage(jsonResponse);
                checkResponseStatus(response);
                System.out.println("\n" + response);
            }
        } catch (IOException ex){
            log.error("Error reading response: {}", ex.getMessage());
        }
    }

    public void checkResponseStatus(String response) {
        ResponseStatus status = ResponseStatus.fromString(response);
        switch (status) {
            case ADMIN_LOGIN_SUCCEEDED:
                loggedIn = true;
                isAuthorized = true;
                log.info("Admin login succeeded");
                break;
            case USER_LOGIN_SUCCEEDED:
                loggedIn = true;
                log.info("User login succeeded");
                break;
            case REGISTRATION_SUCCESSFUL:
                loggedIn = true;
                log.info("User registered succeeded");
                break;
            case LOGOUT_SUCCEEDED:
                loggedIn = false;
                isAuthorized = false;
                log.info("User logout succeeded");
                break;
            case AUTHORIZATION_SUCCEEDED:
                isAuthorized = true;
                log.info("User authorization succeeded");
                break;
            case SWITCH_SUCCEEDED_USER_ROLE_ADMIN_ROLE:
                isAuthorized = true;
                log.info("Switch succeeded for user with admin role");
                break;
            case SWITCH_SUCCEEDED_USER_NON_ADMIN_ROLE:
                isAuthorized = false;
                log.info("Switch succeeded for user with non-admin role");
                break;
            default:
                log.info("No required to take an action");
        }
    }

    public void disconnect() {
        try {
            if (outToServer != null) {
                outToServer.close();
            }
            if (inFromServer != null) {
                inFromServer.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            log.info("Client disconnected");
        } catch (IOException ex) {
            log.error("Error during disconnection: {}", ex.getMessage());
        }
    }

    public boolean isLoggedIn() {
        return loggedIn;
    }

    public boolean isUserAuthorized() {
        return isAuthorized;
    }

    public boolean isConnected(){
        return connected;
    }
}

====================
FILE: DatabaseConnection.java

package database;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class DatabaseConnection {
    private final String USER = "user_manager";
    private final String PASSWORD = "user123";
    private final String DATABASE = "user_db";
    private final int PORT_NUMBER = 5432;
    private final String URL = String.format("jdbc:postgresql://localhost:%d/%s", PORT_NUMBER, DATABASE);
    private static DatabaseConnection instance;
    private static Connection connection;

    public DatabaseConnection() {
        startConnection();
    }

    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    public void startConnection() {
        try {
            log.info("Attempting to connect with data base");
            connection = DriverManager.getConnection(URL, USER, PASSWORD);
            if(connection != null){
                log.info("Connection with {} database established on port {}", USER, PORT_NUMBER);
            } else {
                log.info("Failed to connect with {} database established on port {}", USER, PORT_NUMBER);
            }
        } catch (SQLException ex) {
            log.error("Error during database connection: {}", ex.getMessage());

        }
    }

    public Connection getConnection(){
        return connection;
    }

    public void disconnect() {
        try {
            if (connection != null) {
                connection.close();
                log.info("Database disconnected");
            }
        } catch(SQLException ex){
            log.error("Error during database disconnection: {}", ex.getMessage());
        }
    }
}

====================
FILE: MailDAO.java

package database;

import mail.Mail;
import lombok.extern.log4j.Log4j2;
import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.Record;
import user.credential.User;
import user.manager.UserManager;

import java.util.ArrayList;
import java.util.List;

import static org.jooq.impl.DSL.field;
import static org.jooq.impl.DSL.table;

@Log4j2
public class MailDAO {
    private final DSLContext create;
    private final String MAILS_TABLE = "mails";
    private final UserDAO userDAO;

    public MailDAO(DSLContext create, UserDAO userDAO) {
        this.create = create;
        this.userDAO = userDAO;
    }

    public void saveMailToDB(Mail mail) {
        create.insertInto(table(MAILS_TABLE),
                        field("sender_name"),
                        field("recipient_name"),
                        field("message"),
                        field("status"))
                .values(mail.getSender().getUsername(),
                        mail.getRecipient().getUsername(),
                        mail.getMessage(),
                        mail.getStatus().toString())
                .execute();
    }

    public List<Mail> getMailsFromDB(String boxType) {
        List<Record> records = create.selectFrom(MAILS_TABLE)
                .where(getMailboxCondition(boxType))
                .fetch();

        List<Mail> mails = new ArrayList<>();
        for (Record record : records) {
            System.out.println("in loop");
            Mail mail = convertRecordToMail(record);
            mails.add(mail);
        }
        return mails;
    }

    public void deleteMailsFromDB(String boxType) {
        create.deleteFrom(table(MAILS_TABLE))
                .where(getMailboxCondition(boxType))
                .execute();
    }

    public Mail convertRecordToMail(Record record) {
        String message = record.getValue("message", String.class);
        String senderUsername = record.getValue("sender_name", String.class);
        String recipientUsername = record.getValue("recipient_name", String.class);
        Mail.Status status = Mail.Status.valueOf(record.getValue("status", String.class));

        User sender = userDAO.getUserFromDB(senderUsername);
        User recipient = userDAO.getUserFromDB(recipientUsername);

        return new Mail(sender, recipient, message, status);
    }

    public Condition getMailboxCondition(String boxType) {
        String username = UserManager.currentLoggedInUser.getUsername();
        Condition condition;

        if (boxType.equals(Mail.Status.SENT.toString())) {
            condition = field("sender_name").eq(username)
                    .and(field("status").eq(boxType));
        } else {
            condition = field("recipient_name").eq(username)
                    .and(field("status").eq(boxType));
        }

        return condition;
    }

    public boolean isMailboxFullInDB(User recipient){
        String unread = Mail.Status.UNREAD.toString();

        int messageCount = create.selectFrom(table(MAILS_TABLE))
                .where(field("recipient_name").eq(recipient.getUsername())
                        .and(field("status").eq(unread)))
                .fetch()
                .size();

        return messageCount > 5;
    }

    public void markAsReadInDB() {
        create.update(table(MAILS_TABLE))
                .set(field("status"), Mail.Status.OPENED.toString())
                .where(field("recipient_name").eq(UserManager.currentLoggedInUser.getUsername()))
                .and(field("status").eq(Mail.Status.UNREAD.toString()))
                .execute();

    }
}

====================
FILE: UserDAO.java

package database;

import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.impl.DSL;
import org.mindrot.jbcrypt.BCrypt;
import user.credential.User;

import static org.jooq.impl.DSL.field;
import static org.jooq.impl.DSL.table;

@Log4j2
public class UserDAO {
    private final DSLContext create;
    private final String USERS_TABLE = "users";

    public UserDAO(DSLContext create) {
        this.create = create;
    }

    public void addUserToDB(User user)  {
        create.insertInto(table(USERS_TABLE),
                        field("username"),
                        field("password"),
                        field("role"),
                        field("hashed_password"))
                .values(user.getUsername(),
                        user.getPassword(),
                        user.getRole().toString(),
                        user.getHashedPassword())
                .execute();
    }

    public User getUserFromDB(String username) {
        Record record = create.selectFrom(USERS_TABLE)
                .where(DSL.field("username").eq(username))
                .fetchOne();

        if (record == null) {
            return null;
        }

        return new User(
                record.getValue("username", String.class),
                record.getValue("password", String.class),
                User.Role.valueOf(record.getValue("role", String.class).toUpperCase())
        );
    }

    public boolean checkPasswordInDB(String typedPassword, String username) {
        Record record = create.selectFrom("users")
                .where(DSL.field("username").eq(username))
                .fetchOne();

        String hashed = record.getValue("hashed_password", String.class);

        return BCrypt.checkpw(typedPassword, hashed);
    }

    public void removeUserFromDB(String username) {
        create.deleteFrom(table(USERS_TABLE))
                .where(field("username").eq(username))
                .execute();
    }

    public void changeUserRoleInDB(User user, User.Role role) {
        updateUserInDB(user);
    }

    public void updateUserInDB(User user) {
        create.update(table(USERS_TABLE))
                .set(field("password"), user.getPassword())
                .set(field("role"), user.getRole().toString())
                .set(field("hashed_password"), user.getHashedPassword())
                .where(field("username").eq(user.getUsername()))
                .execute();
    }
}

====================
FILE: Mail.java

package mail;

import lombok.Getter;
import lombok.Setter;
import user.credential.User;
@Getter
@Setter
public class Mail {

    public enum Status{
        UNREAD,
        OPENED,
        SENT;
    }

    private User sender;
    private User recipient;
    private String message;
    private Status status;

    public Mail(User sender, User recipient, String message, Status status) {
        this.sender = sender;
        this.recipient = recipient;
        this.message = message;
        this.status = status;
    }
}

====================
FILE: MailService.java

package mail;

import database.DatabaseConnection;
import database.MailDAO;
import database.UserDAO;
import lombok.extern.log4j.Log4j2;
import lombok.Setter;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import user.credential.User;
import user.manager.UserManager;

import java.util.List;

@Log4j2
@Setter
public class MailService {
    private final DSLContext create;
    private MailDAO mailDAO;
    private UserDAO userDAO;

    public MailService() {
        this.create = DSL.using(DatabaseConnection.getInstance().getConnection());
        this.userDAO = new UserDAO(create);
        this.mailDAO = new MailDAO(create, userDAO);
    }

    public void sendMail(User recipient, String message) {
        log.info("Mail sending to {} from {}", recipient, UserManager.currentLoggedInUser);

        Mail mailToSender = new Mail(UserManager.currentLoggedInUser, recipient, message, Mail.Status.SENT);
        mailDAO.saveMailToDB(mailToSender);

        Mail mailToRecipient = new Mail(mailToSender.getSender(), recipient, message, Mail.Status.UNREAD);
        mailDAO.saveMailToDB(mailToRecipient);

        log.info("Mail successfully sent to {}", recipient.getUsername());
    }

    public List<Mail> getMails(String boxType) {
        return mailDAO.getMailsFromDB(boxType);
    }

    public boolean isMailboxFull(User recipient){
        return mailDAO.isMailboxFullInDB(recipient);
    }


    public void deleteMails(String boxType) {
        log.info("Deleting mails from box: {}", boxType);

        mailDAO.deleteMailsFromDB(boxType);

        log.info("{} mails deleted for user {}", boxType, UserManager.currentLoggedInUser.getUsername());
    }

    public void markAsRead() {
        log.info("Marking mails as read");

        mailDAO.markAsReadInDB();

        log.info("Marked all unread mails as opened for user {}", UserManager.currentLoggedInUser.getUsername());
    }
}

====================
FILE: AuthRequest.java

package request.auth;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class AuthRequest extends Request {
    public AuthRequest (String requestCommand, String username, String password) {
        setCommand(requestCommand);
        setUsername(username);
        setPassword(password);
    }
}

====================
FILE: LogoutRequest.java

package request.auth;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class LogoutRequest extends Request {
    public LogoutRequest(String requestCommand) {
        setCommand(requestCommand);
    }
}

====================
FILE: MailsDeleteRequest.java

package request.mail;
import lombok.extern.log4j.Log4j2;
import request.Request;
@Log4j2
public class MailsDeleteRequest extends Request {
    public MailsDeleteRequest(String boxOperation, String boxType) {
        setCommand(boxOperation);
        setBoxType(boxType);
    }
}

====================
FILE: MailsReadRequest.java

package request.mail;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class MailsReadRequest extends Request {
    public MailsReadRequest(String boxOperation, String boxType) {
        setCommand(boxOperation);
        setBoxType(boxType);
    }
}

====================
FILE: MailWriteRequest.java

package request.mail;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class MailWriteRequest extends Request {
    public MailWriteRequest(String requestCommand, String recipient, String message) {
        setCommand(requestCommand);
        setRecipient(recipient);
        setMessage(message);
    }
}

====================
FILE: Request.java

package request;

import lombok.Getter;
import lombok.Setter;
import user.credential.User;

@Getter
@Setter
public class Request {
    private String command;
    private String username;
    private String password;
    private String recipient;
    private String message;
    private String mailboxOperation;
    private String boxType;
    private String userToUpdate;
    private String newPassword;
    private String userToSwitch;
    private User.Role newRole;
}

====================
FILE: RequestFactory.java

package request;

import lombok.extern.log4j.Log4j2;
import lombok.Getter;
import lombok.Setter;
import client.ClientConnection;
import request.auth.AuthRequest;
import request.auth.LogoutRequest;
import request.mail.MailWriteRequest;
import request.mail.MailsDeleteRequest;
import request.mail.MailsReadRequest;
import request.mail.ServerDetailsRequest;
import request.user.UserChangePasswordRequest;
import request.user.UserChangeRoleRequest;
import request.user.UserRemoveRequest;
import request.user.UserSwitchRequest;

import shared.UserInput;
import user.credential.User;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

@Log4j2
@Getter
@Setter
public class RequestFactory {
    private BufferedReader reader;
    private UserInput userInput;
    private ClientConnection connection;

    public RequestFactory(ClientConnection clientConnection) {
        this.connection = clientConnection;
        this.reader = new BufferedReader(new InputStreamReader(System.in));
        this.userInput = new UserInput(reader);
    }

    public Request getRequest(String command) throws IOException {
        switch (command.toUpperCase()) {
            case "REGISTER":
            case "LOGIN":
                return new AuthRequest(command, userInput.getUsername(), userInput.getPassword());
            case "LOGOUT":
                return new LogoutRequest(command);
            case "WRITE":
                return new MailWriteRequest(command, userInput.getRecipient(), userInput.getMessage());
            case "MAILBOX":
                return getMailboxRequest();
            case "HELP":
            case "INFO":
            case "UPTIME":
                return new ServerDetailsRequest(command);
            case "SWITCH":
                return new UserSwitchRequest(command, userInput.getUserToSwitch());
            case "UPDATE":
                return getUpdateRequest();
            default:
                log.warn("Unknown operation: {}", command);
                return null;
        }
    }

    public Request getMailboxRequest() throws IOException {
        String boxOperation = userInput.chooseBoxOperation();
        String boxType = userInput.chooseBoxType();
        switch (boxOperation) {
            case "READ":
                return new MailsReadRequest(boxOperation, boxType);
            case "DELETE":
                return new MailsDeleteRequest(boxOperation, boxType);
            default:
                log.warn("Unknown mailbox operation: {}", boxOperation);
                return null;
        }
    }

    public Request getUpdateRequest() throws IOException {
            String update = userInput.chooseUpdateOperation();
            String userToUpdate = userInput.chooseUserToUpdate();
            switch (update) {
                case "PASSWORD":
                    String newPassword = userInput.getNewPassword();
                    return new UserChangePasswordRequest(update, userToUpdate, newPassword);
                case "REMOVE":
                    return new UserRemoveRequest(update, userToUpdate);
                case "ROLE":
                    User.Role newRole = userInput.chooseRole();
                    return  new UserChangeRoleRequest(update, userToUpdate, newRole);
                default:
                    log.warn("Unknown update operation: {}", update);
                    return null;
            }
        }
}

====================
FILE: ServerDetailsRequest.java

package request.mail;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class ServerDetailsRequest extends Request{
    public ServerDetailsRequest(String requestCommand) {
        setCommand(requestCommand);
    }
}

====================
FILE: UserChangePasswordRequest.java

package request.user;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class UserChangePasswordRequest extends Request {
    public UserChangePasswordRequest(String updateOperation, String userToUpdate, String newPassword) {
        setCommand(updateOperation);
        setUserToUpdate(userToUpdate);
        setNewPassword(newPassword);
    }
}

====================
FILE: UserChangeRoleRequest.java

package request.user;
import lombok.extern.log4j.Log4j2;
import request.Request;
import user.credential.User;

@Log4j2
public class UserChangeRoleRequest extends Request {
    public UserChangeRoleRequest(String updateOperation, String userToUpdate, User.Role role) {
        setCommand(updateOperation);
        setUserToUpdate(userToUpdate);
        setNewRole(role);
    }
}

====================
FILE: UserRemoveRequest.java

package request.user;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class UserRemoveRequest extends Request {
    public UserRemoveRequest(String updateOperation, String userToDelete) {
        setCommand(updateOperation);
        setUserToUpdate(userToDelete);
    }
}

====================
FILE: UserSwitchRequest.java

package request.user;
import lombok.extern.log4j.Log4j2;
import request.Request;

@Log4j2
public class UserSwitchRequest extends Request {
    public UserSwitchRequest(String requestCommand, String userToSwitch) {
        setCommand(requestCommand);
        setUserToSwitch(userToSwitch);
    }
}

====================
FILE: LoginResponse.java

package response.auth;

import response.Response;
import request.Request;
import user.manager.AuthManager;
import user.manager.UserManager;

public class LoginResponse implements Response {
    private final AuthManager authManager;
    private final UserManager userManager;

    public LoginResponse(AuthManager authManager, UserManager userManager) {
        this.authManager = authManager;
        this.userManager = userManager;
    }
    @Override
    public String execute(Request request) {
        return authManager.loginAndGetResponse(request.getUsername(), request.getPassword(), userManager);
    }
}

====================
FILE: LogoutResponse.java

package response.auth;

import response.Response;
import request.Request;
import user.manager.UserManager;
public class LogoutResponse implements Response {
    private final UserManager userManager;

    public LogoutResponse(UserManager userManager) {
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        return userManager.logoutAndGetResponse();
    }
}

====================
FILE: RegisterResponse.java

package response.auth;

import response.Response;
import request.Request;
import user.manager.AuthManager;
import user.manager.UserManager;
public class RegisterResponse implements Response {
    private final AuthManager authManager;
    private final UserManager userManager;

    public RegisterResponse(AuthManager authManager, UserManager userManager) {
        this.authManager = authManager;
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        return authManager.registerAndGetResponse(request.getUsername(), request.getPassword(), userManager);
    }
}

====================
FILE: MailsDeleteResponse.java

package response.mail;

import response.Response;
import mail.MailService;
import request.Request;
import shared.ResponseStatus;

public class MailsDeleteResponse implements Response {
    private final MailService mailService;

    public MailsDeleteResponse(MailService mailService) {
        this.mailService = mailService;
    }
    @Override
    public String execute(Request request) {
        String boxType = request.getBoxType();
        mailService.deleteMails(boxType);
        return ResponseStatus.MAIL_DELETION_SUCCEEDED.getResponse();
    }
}

====================
FILE: MailsReadResponse.java

package response.mail;

import response.Response;
import mail.Mail;
import mail.MailService;
import request.Request;
import shared.ResponseStatus;

import java.util.List;
public class MailsReadResponse implements Response {
    private final MailService mailService;

    public MailsReadResponse(MailService mailService) {
        this.mailService = mailService;
    }

    @Override
    public String execute(Request request) {
        String boxType = request.getBoxType();
        List<Mail> mailsToRead = mailService.getMails(boxType);

        if (mailsToRead.isEmpty()) {
            return ResponseStatus.MAILBOX_EMPTY.getResponse();
        }

        StringBuilder response = new StringBuilder();
        for (Mail mail : mailsToRead) {
            response.append("From: ")
                    .append(mail.getSender().getUsername())
                    .append("\n Message: ")
                    .append(mail.getMessage())
                    .append("\n");
        }

        if (boxType.equals(Mail.Status.UNREAD.toString())) {
            mailService.markAsRead();
        }
        String mailBoxContent = boxType + " MAILS: \n" + response.toString();
        return  mailBoxContent;
    }
}

====================
FILE: MailWriteResponse.java

package response.mail;

import response.Response;
import mail.MailService;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

public class MailWriteResponse implements Response {
    private final MailService mailService;
    private final UserManager userManager;

    public MailWriteResponse(MailService mailService, UserManager userManager) {
        this.mailService = mailService;
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        String username = request.getRecipient();
        String message = request.getMessage();
        User recipient = userManager.getUserByUsername(username);

        if (recipient == null) {
            return ResponseStatus.SENDING_FAILED_RECIPIENT_NOT_FOUND.getResponse();
        }

        if (mailService.isMailboxFull(recipient)) {
            return ResponseStatus.SENDING_FAILED_BOX_FULL.getResponse();
        }

        if (message.length() >= 255) {
            return ResponseStatus.SENDING_FAILED_TO_LONG_MESSAGE.getResponse();
        }

        mailService.sendMail(recipient, message);
        return ResponseStatus.SENDING_SUCCEEDED.getResponse();
    }
}

====================
FILE: Response.java

package response;

import request.Request;
public interface Response {
    String execute(Request request);
}

====================
FILE: ResponseFactory.java

package response;
import lombok.extern.log4j.Log4j2;
import response.auth.LoginResponse;
import response.auth.LogoutResponse;
import response.auth.RegisterResponse;
import response.mail.MailsDeleteResponse;
import response.mail.MailsReadResponse;
import response.mail.MailWriteResponse;
import response.server.ServerDetailsResponse;
import response.user.UserPasswordChangeResponse;
import response.user.UserRoleChangeResponse;
import response.user.UserRemoveResponse;
import response.user.UserSwitchResponse;
import mail.MailService;
import server.ServerDetails;
import user.manager.AuthManager;
import user.manager.UserManager;

@Log4j2
public class ResponseFactory {
    private final AuthManager authManager;
    private final UserManager userManager;
    private final MailService mailService;
    private final ServerDetails serverDetails;

    public ResponseFactory(AuthManager authManager, UserManager userManager, MailService mailService, ServerDetails serverDetails) {
        this.authManager = authManager;
        this.userManager = userManager;
        this.mailService = mailService;
        this.serverDetails = serverDetails;
    }

    public Response getResponse(String request)  {
        switch (request.toUpperCase()) {
            case "REGISTER":
                return new RegisterResponse(authManager, userManager);
            case "LOGIN":
                return new LoginResponse(authManager, userManager);
            case "LOGOUT":
                return new LogoutResponse(userManager);
            case "WRITE":
                return new MailWriteResponse(mailService, userManager);
            case "READ":
                return new MailsReadResponse(mailService);
            case "DELETE":
                return new MailsDeleteResponse(mailService);
            case "PASSWORD":
                return new UserPasswordChangeResponse(userManager);
            case "REMOVE":
                return new UserRemoveResponse(userManager);
            case "ROLE":
                return new UserRoleChangeResponse(userManager);
            case "SWITCH":
                return new UserSwitchResponse(userManager);
            case "HELP":
            case "INFO":
            case "UPTIME":
                return new ServerDetailsResponse(serverDetails);
            default:
                log.warn("Unknown operation: {}", request);
                return null;
        }
    }
}

====================
FILE: ServerDetailsResponse.java

package response.server;

import response.Response;
import request.Request;
import server.ServerDetails;
import shared.ResponseStatus;

public class ServerDetailsResponse implements Response {
    private final ServerDetails serverDetails;
    public ServerDetailsResponse(ServerDetails serverDetails) {
        this.serverDetails = serverDetails;
    }
    @Override
    public String execute(Request request) {
        String serverRequest = request.getCommand().toUpperCase();
        StringBuilder builder = new StringBuilder();
        
        switch (serverRequest) {
            case "UPTIME":
                builder.append("Uptime:\n");
                builder.append(String.format("%d days, %d hours, %d minutes, %d seconds",
                        serverDetails.getUptime().get("Days"),
                        serverDetails.getUptime().get("Hours"),
                        serverDetails.getUptime().get("Minutes"),
                        serverDetails.getUptime().get("Seconds")));
                return builder.toString();
            case "INFO":
                builder.append("Server Info:\n");
                serverDetails.getServerDetails().forEach((key, value) -> builder.append(key).append(" = ").append(value).append("\n"));
                return builder.toString();
            case "HELP":
                builder.append("Available Commands:\n");
                serverDetails.getCommands().forEach((key, value) -> builder.append(key).append(" - ").append(value).append("\n"));
                return builder.toString();
            default:
                return ResponseStatus.UNKNOWN_REQUEST.getResponse();
        }
    }
}

====================
FILE: UserPasswordChangeResponse.java

package response.user;

import response.Response;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;
public class UserPasswordChangeResponse implements Response {
    private final UserManager userManager;

    public UserPasswordChangeResponse(UserManager userManager) {
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        if (userManager.isUserAdmin()) {
            User user = userManager.getUserByUsername(request.getUserToUpdate());
            if (user == null) {
                return ResponseStatus.FAILED_TO_FIND_USER.getResponse();
            }
            userManager.changePassword(user, request.getNewPassword());
            return ResponseStatus.OPERATION_SUCCEEDED.getResponse();
        } else {
            return ResponseStatus.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: UserRemoveResponse.java

package response.user;

import response.Response;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;
public class UserRemoveResponse implements Response {
    private final UserManager userManager;

    public UserRemoveResponse(UserManager userManager) {
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        if (userManager.isUserAdmin()) {
            User user = userManager.getUserByUsername(request.getUserToUpdate());
            if (user == null) {
                return ResponseStatus.FAILED_TO_FIND_USER.getResponse();
            }
            userManager.removeUser(user);
            return ResponseStatus.OPERATION_SUCCEEDED.getResponse();
        } else {
            return ResponseStatus.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: UserRoleChangeResponse.java

package response.user;

import response.Response;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;
public class UserRoleChangeResponse implements Response {
    private final UserManager userManager;

    public UserRoleChangeResponse(UserManager userManager) {
        this.userManager = userManager;
    }
    @Override
    public String execute(Request request) {
        if (userManager.isUserAdmin()) {
            User user = userManager.getUserByUsername(request.getUserToUpdate());

            if (user == null) {
                return ResponseStatus.FAILED_TO_FIND_USER.getResponse();
            }

            userManager.changeUserRole(user, request.getNewRole());
            return ResponseStatus.ROLE_CHANGE_SUCCEEDED.getResponse();
        } else {
            return ResponseStatus.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: UserSwitchResponse.java

package response.user;

import response.Response;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

public class UserSwitchResponse implements Response {
    private final UserManager userManager;
    public UserSwitchResponse(UserManager userManager) {
        this.userManager = userManager;
    }

    @Override
    public String execute(Request request) {
        User user = userManager.getUserByUsername(request.getUserToSwitch());

        if (user == null) {
            return ResponseStatus.SWITCH_FAILED.getResponse() + ": user not found";
        }

        if (!userManager.isUserAdmin()) {
            return ResponseStatus.SWITCH_FAILED.getResponse() + ": user not authorized";
        }

        userManager.switchUser(user);

        if (UserManager.ifSwitchedToAdminUser) {
            return ResponseStatus.SWITCH_SUCCEEDED_USER_ROLE_ADMIN_ROLE.getResponse();
        }

        if(UserManager.ifSwitchedToNonAdminUser) {
            return ResponseStatus.SWITCH_SUCCEEDED_USER_NON_ADMIN_ROLE.getResponse();
        }

        return ResponseStatus.SWITCH_FAILED.getResponse();
    }
}


====================
FILE: Server.java

package server;

import database.DatabaseConnection;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class Server {
    private static final int PORT = 5000;
    public static void main(String[] args) {
        log.info("Starting server on port {}", PORT);
        ServerConnection connectionHandler = new ServerConnection(PORT);
        connectionHandler.startServer();
        ServerRequestService logicHandler = new ServerRequestService(
                connectionHandler.getOutToClient(),
                connectionHandler.getInFromClient());

        logicHandler.handleClientRequest();

        try {
            logicHandler.handleClientRequest();
        } finally {
            connectionHandler.closeConnections();
            DatabaseConnection.getInstance().disconnect();
        }

    }
}

====================
FILE: ServerConnection.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Date;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

@Log4j2
@Getter
@Setter
public class ServerConnection {
    private int port;
    public static Date serverTimeCreation;
    private ServerSocket serverSocket;
    private Socket clientSocket;
    private BufferedReader inFromClient;
    private PrintWriter outToClient;

    public ServerConnection(int port) {
        this.port = port;
    }

    public void startServer(){
        try{
            log.info("Starting server on port {}", port);
            serverTimeCreation = new Date();
            serverSocket = new ServerSocket(port);
            log.info("Server socket created on port {}", port);
            clientSocket = serverSocket.accept();
            log.info("Connection with client established");
            inFromClient = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            outToClient = new PrintWriter(clientSocket.getOutputStream(), true);
        } catch (IOException ex){
            log.error("Error starting server on port {}: {}", port, ex.getMessage());
        }
    }

    public BufferedReader getInFromClient() {
        return inFromClient;
    }

    public PrintWriter getOutToClient() {
        return outToClient;
    }

    public void closeConnections() {
        try {
            log.info("Closing server and client connections");
            if (inFromClient != null) {
                inFromClient.close();
            }
            if (outToClient != null) {
                outToClient.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            if (serverSocket != null) {
                serverSocket.close();
            }
            log.info("Server disconnected");
        } catch (IOException ex) {
            log.error("Error closing connections: {}", ex.getMessage());
        }
    }
}

====================
FILE: ServerDetails.java

package server;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

/**
 * The ServerDetails class provides information about the server.
 */
@Getter
@Setter
@Log4j2
public class ServerDetails {
    private final String VERSION = "1.0.0";
    private Map<String, String> commands = new LinkedHashMap<>();
    private Map<String, String> serverDetails = new LinkedHashMap<>();
    private Map<String, Long> uptime = new LinkedHashMap<>();

    public ServerDetails() {
        setCommands();
        setServerDetails();
        setUptime();
    }

   public void setUptime(){
       Date currentTime = new Date();
       long uptimeInMillis = currentTime.getTime() - ServerConnection.serverTimeCreation.getTime();

       long days = TimeUnit.MILLISECONDS.toDays(uptimeInMillis);
       long hours = TimeUnit.MILLISECONDS.toHours(uptimeInMillis) % 24;
       long minutes = TimeUnit.MILLISECONDS.toMinutes(uptimeInMillis) % 60;
       long seconds = TimeUnit.MILLISECONDS.toSeconds(uptimeInMillis) % 60;

       uptime.put("Days", days);
       uptime.put("Hours", hours);
       uptime.put("Minutes", minutes);
       uptime.put("Seconds", seconds);
    }

    public void setCommands() {
        commands.put("Login", "Login to your account");
        commands.put("Register", "Create a new user account");
        commands.put("Help", "All commands list");
        commands.put("Uptime", "Check server uptime");
        commands.put("Info", "Server version and date");
        commands.put("Exit", "Stop server and client");

    }

    public void setServerDetails() {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
        String setupTimeFormatted = dateFormat.format(ServerConnection.serverTimeCreation);
        serverDetails.put("Version", VERSION);
        serverDetails.put("Setup time", setupTimeFormatted);
    }
}

====================
FILE: ServerRequestService.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

import com.google.gson.Gson;
import response.Response;
import response.ResponseFactory;
import lombok.extern.log4j.Log4j2;
import mail.MailService;
import request.Request;
import shared.JsonConverter;
import user.manager.AuthManager;
import user.manager.UserManager;

@Log4j2
public class ServerRequestService {
    private final PrintWriter outToClient;
    private final BufferedReader inFromClient;
    private final UserManager userManager;
    private Gson gson;
    private JsonConverter jsonResponse;
    private AuthManager authManager;
    private ServerDetails serverDetails;
    private MailService mailService;


    public ServerRequestService(PrintWriter outToClient, BufferedReader inFromClient) {
        this.outToClient = outToClient;
        this.inFromClient = inFromClient;
        this.userManager = new UserManager();
        this.gson = new Gson();

        this.authManager = new AuthManager();
        this.mailService = new MailService();
        this.serverDetails = new ServerDetails();
    }

    public void handleClientRequest() {
        String request;
        try {
            while ((request = inFromClient.readLine()) != null) {
                Request req = getParseRequest(request);
                String response = processRequest(req);
                sendResponse(response);
            }
        } catch (IOException ex) {
            log.error("IOException occurred while processing the request: {}. Error: ", ex.getMessage());
        }
    }

    public Request getParseRequest(String request){
        log.info("Parsing request: {}", request);
        return gson.fromJson(request, Request.class);
    }

     public String processRequest(Request req) throws IOException{
         String requestCommand = req.getCommand().toUpperCase();
         ResponseFactory factory = new ResponseFactory(authManager, userManager,mailService, serverDetails);
         Response command = factory.getResponse(requestCommand);
         log.info("Handling request command: {}", command.toString());
         return command.execute(req);
     }

    public void sendResponse(String response){
        jsonResponse = new JsonConverter(response);
        String json = jsonResponse.serializeMessage();
        outToClient.println(json);
        log.info("Response sent: {}", json);
    }
}

====================
FILE: JsonConverter.java

package shared;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class JsonConverter {
    private String message;

    public JsonConverter(String message) {
        this.message = message;
    }

    public String serializeMessage() {
        log.info("Serializing message");
        try {
            Gson gson = new Gson();
            return gson.toJson(this) + "\n<<END>>";
        } catch (Exception e) {
            throw new IllegalStateException("Error - failed to serialize JsonResponse to JSON", e);
        }
    }

    public static String deserializeMessage(String json) {
        log.info("Deserializing message");
        if (json == null || json.trim().isEmpty()) {
            throw new IllegalArgumentException("Input JSON is null or empty");
        }
        try {
            Gson gson = new Gson();
            JsonConverter jsonConverter = gson.fromJson(json, JsonConverter.class);
            log.info("Deserialized message: {}", json);
            return jsonConverter.toString();
        } catch (JsonSyntaxException e) {
            throw new IllegalArgumentException("Error deserializing JSON. Please check syntax", e);
        }
    }

    @Override
    public String toString() {
        return message;
    }
}

====================
FILE: ResponseStatus.java

package shared;

import lombok.extern.log4j.Log4j2;

@Log4j2
public enum ResponseStatus {

    // General responses
    OPERATION_SUCCEEDED("Operation succeeded"),
    FAILED_TO_FIND_USER("Failed to find user"),

    // Register responses
    REGISTRATION_SUCCESSFUL("Registration successful"),
    REGISTRATION_FAILED_USER_EXISTS("Registration failed: User already exists"),

    // Login responses
    USER_LOGIN_SUCCEEDED("User login successful"),
    ADMIN_LOGIN_SUCCEEDED("Admin login successful"),
    LOGIN_FAILED_INCORRECT_PASSWORD("Login failed: Incorrect password"),

    // Logout response
    LOGOUT_SUCCEEDED("Logout succeeded"),

    // Authorization responses
    AUTHORIZATION_SUCCEEDED("Authorization succeeded"),
    AUTHORIZATION_FAILED("Authorization failed"),

    // Account switch responses
    SWITCH_SUCCEEDED_USER_ROLE_ADMIN_ROLE("Switch succeeded to admin role user"),
    SWITCH_SUCCEEDED_USER_NON_ADMIN_ROLE("Switch succeeded to non-admin role user"),
    SWITCH_FAILED("Switch failed"),

    // Role change responses
    ROLE_CHANGE_SUCCEEDED("Role change succeeded"),

    // Mail responses
    SENDING_SUCCEEDED("Sending succeeded"),
    SENDING_FAILED_BOX_FULL("Sending failed: Recipient's mailbox is full"),
    SENDING_FAILED_TO_LONG_MESSAGE("Sending failed: Message too long (maximum 255 characters)"),
    SENDING_FAILED_RECIPIENT_NOT_FOUND("Sending failed: Recipient not found"),
    MAIL_DELETION_SUCCEEDED("Mails deletion succeeded"),
    MAILBOX_EMPTY("Mailbox is empty"),

    // Unknown Message
    UNKNOWN_REQUEST("Unknown request"),
    UNKNOWN_RESPONSE("Unknown response");

    private final String RESPONSE;

    ResponseStatus(String response) {
        this.RESPONSE = response;
    }

    public String getResponse() {
        return RESPONSE;
    }

    /**
     * Converts a string to the corresponding ResponseMessage enum value
     * Iterate over all the values in the ResponseMessage enum
     * Check if the 'response' field of the current enum value matches the input text
     * If a operation is mail reading or match is found, return the corresponding ResponseMessage enum value
     */
    public static ResponseStatus fromString(String text) {
        log.info("Converting text to OperationResponses");
        for (ResponseStatus message : ResponseStatus.values()) {
            if (isMailReading(text) || message.getResponse().equals(text)) {
                log.info("Match found for response");
                return message;
            }
        }
        log.warn("No match found for response:" + text);
        return UNKNOWN_RESPONSE;
    }

    static boolean isMailReading(String text) {
        return text.startsWith("OPENED") || text.startsWith("UNREAD") || text.startsWith("SENT");
    }
}


====================
FILE: Screen.java

package shared;

public class Screen {

    public static void printLoginMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              Welcome in MailBox!            |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Register                                    |\n" +
                "| Login                                       |\n" +
                "| Uptime                                      |\n" +
                "| Info                                        |\n" +
                "| Help                                        |\n" +
                "| Exit                                        |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printAdminMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Update                                      |\n" +
                "| Switch                                      |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printUserMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }
}

====================
FILE: UserInput.java

package shared;

import java.io.BufferedReader;
import java.io.IOException;

import user.credential.User.Role;

public class UserInput {
    private BufferedReader reader;
    public UserInput(BufferedReader reader) {
        this.reader = reader;
    }

    public String getUsername() throws IOException {
        System.out.print("Please type your username: ");
        return reader.readLine();
    }

    public String getPassword() throws IOException {
        System.out.print("Please type your password: ");
        return reader.readLine();
    }

    public String getNewPassword() throws IOException{
        System.out.print("Please type a new password: ");
        return reader.readLine();
    }

    public String getRecipient() throws IOException {
        System.out.print("Please type a recipient's username: ");
        return reader.readLine();
    }

    public String getMessage() throws IOException {
        System.out.println("Please type your message (max 255 characters): ");
        return reader.readLine();
    }

     public String getUserToSwitch() throws IOException {
         System.out.print("Please type a username to switch: ");
         return reader.readLine();
     }

    public String chooseBoxOperation() throws IOException {
        while (true) {
            System.out.println("Mailbox operation: READ / DELETE: ");
            System.out.print("Select: ");
            String operation = reader.readLine().toUpperCase();
            switch (operation) {
                case "READ":
                case "DELETE":
                    return operation;
                default:
                    System.out.println("Invalid operation. Please try again!");;
            }
        }
    }
    public String chooseBoxType() throws IOException {
        while (true) {
                System.out.println("Mailbox type: OPENED / UNREAD / SENT");
                System.out.print("Select: ");
                String mailbox = reader.readLine().toUpperCase();
                switch (mailbox) {
                    case "OPENED":
                    case "UNREAD":
                    case "SENT":
                        return mailbox;
                    default:
                        System.out.println("Invalid mailbox type. Please try again!");
                }
        }
    }

    public String chooseUpdateOperation() throws IOException {
        while (true) {
            System.out.println("Update operations: PASSWORD / REMOVE / ROLE");;
            System.out.print("Select: ");;
            String input = reader.readLine().toUpperCase();
            switch (input) {
                case "PASSWORD":
                    return "PASSWORD";
                case "REMOVE":
                    return "REMOVE";
                case "ROLE":
                    return "ROLE";
                default:
                    System.out.println("Invalid operation type. Please try again!");
            }
        }
    }

    public String chooseUserToUpdate() throws IOException {
        System.out.print("Please type an username to update: ");
        return reader.readLine();
    }

    public Role chooseRole() throws IOException {
        System.out.print("Please type the new role (ADMIN / USER): ");
        String newRole = reader.readLine().toUpperCase();
        if(newRole.equals("ADMIN")){
            return Role.ADMIN;
        } else {
            return Role.USER;
        }
    }
}

====================
FILE: Admin.java

package user.credential;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class Admin extends User {
    public Admin() {
        super("admin", "java10", Role.ADMIN);
    }
}



====================
FILE: User.java

package user.credential;

import org.mindrot.jbcrypt.BCrypt;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

@Getter
@Setter
@Log4j2
public class User {

    public enum Role {
        ADMIN,
        USER;
    }

    protected String username;
    protected String password;
    protected String hashedPassword;
    protected Role role;

    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
    }

    public void hashPassword() {
        hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        log.info("Password hashed for user: {}", username);
    }

    public void setPassword(String newPassword) {
        this.password = newPassword;
        hashPassword();
        log.info("New password set for user: {}", username);
    }

    public String toString() {
        return username;
    }
}

====================
FILE: AuthManager.java

package user.manager;

import lombok.extern.log4j.Log4j2;
import shared.ResponseStatus;
import user.credential.User;

@Log4j2
public class AuthManager {

    public String registerAndGetResponse(String username, String password, UserManager userManager) {
        log.info("Registration attempted for user: {}", username);
        User user = userManager.getUserDAO().getUserFromDB(username);

        if (user != null) {
            log.info("Registration attempt failed - user already exists: {}", username);
            return ResponseStatus.REGISTRATION_FAILED_USER_EXISTS.getResponse();
        }

        handleRegister(username, password, userManager);
        log.info("Registration successful for new user: {}", username);
        return ResponseStatus.REGISTRATION_SUCCESSFUL.getResponse();
    }

    public String loginAndGetResponse(String username, String password, UserManager userManager) {
        log.info("Login attempted for user: {}", username);
        User user = userManager.getUserDAO().getUserFromDB(username);
        if (user == null) {
            log.info("Login attempt failed - user does not exist: {}", username);
            return ResponseStatus.FAILED_TO_FIND_USER.getResponse();
        }

        if (!ifPasswordCorrect(password, user, userManager)) {
            log.info("Incorrect password attempt for user: {}", user.getUsername());
            return ResponseStatus.LOGIN_FAILED_INCORRECT_PASSWORD.getResponse();
        }

        log.info("User password correct: {}", user.getUsername());

        handleLogin(user);

        log.info("User login succeeded: {}", user.getUsername());

        if (userManager.isUserAdmin()) {
            return ResponseStatus.ADMIN_LOGIN_SUCCEEDED.getResponse();
        } else {
            return ResponseStatus.USER_LOGIN_SUCCEEDED.getResponse();
        }
    }

    public void handleRegister(String username, String password, UserManager userManager) throws IllegalArgumentException {
        User newUser = new User(username, password, User.Role.USER);

        userManager.getUserDAO().addUserToDB(newUser);
        UserManager.currentLoggedInUser = newUser;
    }

    public void handleLogin(User existingUser) {
        UserManager.currentLoggedInUser = existingUser;
    }

    public boolean ifPasswordCorrect(String password, User user, UserManager userManager) {
        return userManager.getUserDAO().checkPasswordInDB(password, user.getUsername());
    }
}

====================
FILE: UserManager.java

package user.manager;

import database.DatabaseConnection;
import database.UserDAO;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import shared.ResponseStatus;
import user.credential.Admin;
import user.credential.User;

@Log4j2
@Getter
@Setter
public class UserManager {
    public static User currentLoggedInUser;
    public static boolean ifSwitchedToNonAdminUser;
    public static boolean ifSwitchedToAdminUser;
    public Admin admin;
    private DSLContext create;
    private UserDAO userDAO;
    private AuthManager authManager;

    public UserManager() {
        this.create = DSL.using(DatabaseConnection.getInstance().getConnection());
        this.userDAO = new UserDAO(create);
        this.admin = new Admin();
        this.authManager = new AuthManager();
    }

    public User getUserByUsername(String username) {
        log.info("Searching for user in the database: {}", username);

        User user = userDAO.getUserFromDB(username);

        if (user == null) {
            log.warn("User not found in database: {}", username);
            return null;
        }
        log.info("User found in database: {}", username);
        return user;
    }

    public void changePassword(User user, String newPassword) {
        log.info("Attempting to password change for user: {}", user.getUsername());

        user.setPassword(newPassword);

        log.info("Attempting to upload database: {}", user.getUsername());
        userDAO.updateUserInDB(user);

        log.info("Data base upload succeeded {}", user.getUsername());
        log.info("Password change succeeded for user: {}", user.getUsername());
    }

    public void removeUser(User user) {
        log.info("Attempting to remove user: {}", user.getUsername());

        userDAO.removeUserFromDB(user.getUsername());

        log.info("User removal succeeded: {}", user.getUsername());
    }

    public void switchUser(User user) {
        log.info("Attempting to switch to user: {}", user.getUsername());
            UserManager.currentLoggedInUser = user;

            if(isUserAdmin()){
                UserManager.ifSwitchedToAdminUser = true;
            } else {
                UserManager.ifSwitchedToNonAdminUser = true;
            }
        log.info("Switched to user: {}", user.getUsername());
    }

    public void changeUserRole(User user, User.Role role) {
        log.info("Attempting to role change for user: {}", user.getUsername());

        user.setRole(role);
        userDAO.changeUserRoleInDB(user, role);

        log.info("Role change succeeded for user: {} to {}", user.getUsername(), role);
    }

    public String logoutAndGetResponse() {
        log.info("User logout requested");

        ifSwitchedToNonAdminUser = false;
        currentLoggedInUser = null;

        return ResponseStatus.LOGOUT_SUCCEEDED.getResponse();
    }

    public boolean isUserAdmin(){
        log.info("Admin role checking for user: {}", currentLoggedInUser.getUsername());
        return currentLoggedInUser != null && currentLoggedInUser.getRole().equals(User.Role.ADMIN);
    }

}

====================
FILE: ClientCommunicationTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;

import org.junit.jupiter.api.*;
import shared.ResponseStatus;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ClientCommunicationTest {
    static ClientConnection clientConnection;
    Socket mockSocket;
    PrintWriter mockOutToServer;
    BufferedReader mockInFromServer;

    @BeforeEach
    void setUp() {
        mockSocket = mock(Socket.class);
        mockOutToServer = mock(PrintWriter.class);
        mockInFromServer = mock(BufferedReader.class);
        clientConnection = new ClientConnection();
        clientConnection.setClientSocket(mockSocket);
        clientConnection.setOutToServer(mockOutToServer);
        clientConnection.setInFromServer(mockInFromServer);
    }

    @AfterAll
    static void closeDown() {
        clientConnection.disconnect();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectToServer()  {
        Assertions.assertTrue(clientConnection.isConnected());
    }

    @Test
    @DisplayName("Should test sending request")
    void testSendRequest() {
        String request = "testRequest";

        clientConnection.sendRequest(request);

        // Verify that the request was sent to the server
        verify(mockOutToServer).println(request);
    }

    @Test
    @DisplayName("Should test checking response status")
    void testReadResponse() throws IOException {
        String jsonResponse1 = "{\"message\":\"response1\"}";
        String jsonResponse2 = "{\"message\":\"response2\"}";

        // Mock server responses
        when(mockInFromServer.readLine())
                .thenReturn(jsonResponse1, jsonResponse2, "<<END>>");

        clientConnection.readResponse();

        // Verify that the responses were read from the server
        verify(mockInFromServer, times(3)).readLine();
    }

    @Test
    @DisplayName("Should check response status")
    void testCheckResponseStatus() {
        // Test admin login succeeded
        String response = ResponseStatus.ADMIN_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());
        assertTrue(clientConnection.isUserAuthorized());

        // Test user login succeeded
        response = ResponseStatus.USER_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test registration succeeded
        response = ResponseStatus.REGISTRATION_SUCCESSFUL.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test logout succeeded
        response = ResponseStatus.LOGOUT_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isLoggedIn());
        assertFalse(clientConnection.isUserAuthorized());

        // Test authorization succeeded
        response = ResponseStatus.AUTHORIZATION_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isUserAuthorized());

        // Test switch operation succeeded for admin
        response = ResponseStatus.SWITCH_SUCCEEDED_USER_ROLE_ADMIN_ROLE.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isUserAuthorized());

        // Test switch operation succeeded for non-admin user
        response = ResponseStatus.SWITCH_SUCCEEDED_USER_NON_ADMIN_ROLE.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isUserAuthorized());
    }
}

====================
FILE: ClientTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;

import org.junit.jupiter.api.*;
import org.mockito.MockedStatic;
import request.Request;
import request.RequestFactory;
import shared.Screen;
import shared.UserInput;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static shared.Screen.printAdminMailBoxMenu;

class ClientTest {
    Client client;
    static ClientConnection mockConnection;
    BufferedReader mockReader;
    UserInput mockUserInput;
    RequestFactory mockRequestFactory;
    Request mockRequestType;

    @BeforeEach
    void setUp() {
        client = new Client();
        mockConnection = mock(ClientConnection.class);
        mockReader = mock(BufferedReader.class);
        client.setConnection(mockConnection);
        client.setUserInput(mockReader);
        mockUserInput = mock(UserInput.class);
        mockRequestFactory = mock(RequestFactory.class);
        mockRequestType = mock(Request.class);
    }

    @AfterAll
    static void closeDown() {
        mockConnection.disconnect();
    }

    @Test
    @DisplayName("Should test disconnect when user inputs 'EXIT'")
    void testHandleServerCommunication_EXIT() throws IOException {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockReader.readLine()).thenReturn("EXIT");

        client.handleServerCommunication();

        // Verify that the client disconnects from the server when "EXIT" is entered
        assertTrue(mockConnection.isConnected());
        assertTrue(mockConnection.isLoggedIn());
        verify(mockConnection, times(1)).disconnect();
    }

    @Test
    @DisplayName("Should test communication handling when admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockConnection.isUserAuthorized()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> printAdminMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when non-admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Not_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> Screen.printUserMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT LOGGED IN")
    void testHandleServerCommunication_NotLoggedIn() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(false);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the login menu is displayed when the user is not logged in
        mockScreen.verify(() -> Screen.printLoginMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT CONNECTED")
    void testHandleServerCommunication_NotConnected() throws IOException {
        when(!mockConnection.isConnected()).thenReturn(false);

        client.handleServerCommunication();

        // Verify that no actions are taken when the client is not connected
        verify(mockConnection, never()).isLoggedIn();
        verify(mockReader, never()).readLine();
    }

    @Test
    @DisplayName("Should test request handling")
    void testHandleRequest() throws IOException {
        when(mockReader.readLine()).thenReturn("LOGIN");
        when(mockRequestFactory.getRequest("LOGIN")).thenReturn(mockRequestType);

        client.handleRequest("LOGIN");

        // Verify that the request is handled properly
        verify(mockConnection).sendRequest(anyString());
        verify(mockConnection).readResponse();
    }
}

====================
FILE: DatabaseConnectionTest.java

package database;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class DatabaseConnectionTest {
    static DatabaseConnection databaseConnection;
    static Connection mockConnection;


    @BeforeEach
    void setUp() {
        databaseConnection  = DatabaseConnection.getInstance();
        mockConnection = mock(Connection.class);
    }

    @AfterAll
    static void closeDown() {
        databaseConnection.disconnect();
    }

    @Test
    @DisplayName("Should test connection with data base")
    void testStartConnection()  {
        assertNotNull(databaseConnection.getConnection());
    }

    @Test
    @DisplayName("Should test data base connection return")
    void testGetConnection()  {
        Connection connection = databaseConnection.getConnection();

        assertNotNull(connection);
    }

    @Test
    @DisplayName("Should test data base disconnect")
    void testDisconnect() throws SQLException {
        Connection connection = databaseConnection.getConnection();

        databaseConnection.disconnect();

        assertTrue(connection.isClosed());
    }
}

====================
FILE: MailDAOTest.java

package database;

public class MailDAOTest {
}

====================
FILE: UserDAOTest.java

package database;

public class UserDAOTest {
}

====================
FILE: MailServiceTest.java

package mail;

import database.MailDAO;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.User;
import user.manager.UserManager;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.mockito.Mockito.times;

public class MailServiceTest {
    User sender;
    User recipient;
    Mail mail;
    MailService mailService;
    MailDAO mockMailDAO;

    @BeforeEach
    void setUp() {
        mockMailDAO = mock(MailDAO.class);
        mailService = new MailService();
        mailService.setMailDAO(mockMailDAO);
        sender = new User("senderName", "testPassword", User.Role.USER);
        UserManager.currentLoggedInUser = sender;
        recipient = new User("recipientName", "testPassword", User.Role.USER);
        mail = new Mail(sender, recipient, "test message", Mail.Status.UNREAD);
    }

    @Test
    @DisplayName("Should test mail sending")
    void testSendMail() {
        mailService.sendMail(recipient, "message");

        // verify if mail has been saved in DB
        verify(mockMailDAO, times(2)).saveMailToDB(any(Mail.class));
    }

    @Test
    @DisplayName("Should test getting mails from the database")
    void getMails() {
        String mailbox = "UNREAD";
        List<Mail> expectedMails = List.of(mail);

        when(mockMailDAO.getMailsFromDB(mailbox)).thenReturn(expectedMails);

        List<Mail> mails = mailService.getMails(mailbox);

        assertEquals(expectedMails, mails);
    }

    @Test
    @DisplayName("Should test if mailbox is full in the database")
    void testisMailboxFull() {
        when(mailService.isMailboxFull(recipient)).thenReturn(true);
        boolean isFull = mailService.isMailboxFull(recipient);

        assertTrue(isFull);
    }

    @Test
    @DisplayName("Should test deleting mails from the database")
    void testDeleteMails() {
        String mailbox = "UNREAD";

        mailService.deleteMails(mailbox);

        verify(mockMailDAO,times(1)).deleteMailsFromDB(mailbox);
    }

    @Test
    @DisplayName("Should test if message is marked as read in the database")
    void testMarkAsRead() {
        mailService.markAsRead();

        verify(mockMailDAO,times(1)).markAsReadInDB();
    }
}

====================
FILE: RequestFactoryTest.java

package request;

import java.io.IOException;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.auth.AuthRequest;
import request.auth.LogoutRequest;
import request.mail.MailWriteRequest;
import request.mail.MailsDeleteRequest;
import request.mail.MailsReadRequest;
import request.mail.ServerDetailsRequest;
import request.user.UserChangePasswordRequest;
import request.user.UserChangeRoleRequest;
import request.user.UserRemoveRequest;
import request.user.UserSwitchRequest;
import shared.UserInput;
import client.ClientConnection;
import user.credential.User;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class RequestFactoryTest {
    UserInput mockUserInput;
    ClientConnection mockClientConnection;
    RequestFactory factory;

    @BeforeEach
    void setUp() {
        mockUserInput = mock(UserInput.class);
        mockClientConnection = mock(ClientConnection.class);
        factory = new RequestFactory(mockClientConnection);
        factory.setUserInput(mockUserInput);
    }

    @Test
    @DisplayName("Should test authRequest return")
    public void testGetAuthRequest() throws IOException {
        when(mockUserInput.getUsername()).thenReturn("testUser");
        when(mockUserInput.getPassword()).thenReturn("testPassword");

        AuthRequest request = (AuthRequest) factory.getRequest("LOGIN");

        assertNotNull(request);
        assertEquals("LOGIN", request.getCommand());
        assertEquals("testUser", request.getUsername());
        assertEquals("testPassword", request.getPassword());
    }

    @Test
    @DisplayName("Should test logoutRequest return")
    public void testGetLogoutRequest() throws IOException {
        Request request = factory.getRequest("LOGOUT");
        LogoutRequest logoutRequest = (LogoutRequest) request;
        assertEquals("LOGOUT", logoutRequest.getCommand());
    }


    @Test
    @DisplayName("Should test MailWriteRequest return")
    public void testGetMailWriteRequest() throws IOException {
        when(mockUserInput.getRecipient()).thenReturn("recipient");
        when(mockUserInput.getMessage()).thenReturn("message");

        Request request = factory.getRequest("WRITE");

        MailWriteRequest mailWriteRequest = (MailWriteRequest) request;
        assertEquals("WRITE", mailWriteRequest.getCommand());
        assertEquals("recipient", mailWriteRequest.getRecipient());
        assertEquals("message", mailWriteRequest.getMessage());
    }

    @Test
    @DisplayName("Should test MailboxReadRequest return")
    public void testGetMailboxReadRequest() throws IOException {
        when(mockUserInput.chooseBoxOperation()).thenReturn("READ");
        when(mockUserInput.chooseBoxType()).thenReturn("OPENED");

        Request request = factory.getMailboxRequest();

        MailsReadRequest mailsReadRequest = (MailsReadRequest) request;
        assertEquals("READ", mailsReadRequest.getCommand());
        assertEquals("OPENED", mailsReadRequest.getBoxType());
    }
    @Test
    @DisplayName("Should test MailboxDeleteRequest return")
    public void testGetMailboxDeleteRequest() throws IOException {
        when(mockUserInput.chooseBoxOperation()).thenReturn("DELETE");
        when(mockUserInput.chooseBoxType()).thenReturn("UNREAD");

        Request request = factory.getMailboxRequest();

        MailsDeleteRequest mailsDeleteRequest = (MailsDeleteRequest) request;
        assertEquals("DELETE", mailsDeleteRequest.getCommand());
        assertEquals("UNREAD", mailsDeleteRequest.getBoxType());
    }

    @Test
    @DisplayName("Should test ServerDetailsRequest return")
    public void testGetServerDetailsRequest() throws IOException {
        Request request = factory.getRequest("INFO");

        ServerDetailsRequest serverDetailsRequest = (ServerDetailsRequest) request;
        assertEquals("INFO", serverDetailsRequest.getCommand());
    }

    @Test
    @DisplayName("Should test UserSwitchRequest return")
    public void testGetUserSwitchRequest() throws IOException {
        when(mockUserInput.getUserToSwitch()).thenReturn("exampleUser");

        Request request = factory.getRequest("SWITCH");

        UserSwitchRequest userSwitchRequest = (UserSwitchRequest) request;
        assertEquals("SWITCH", userSwitchRequest.getCommand());
        assertEquals("exampleUser", userSwitchRequest.getUserToSwitch());
    }

    @Test
    @DisplayName("Should test UserChangePasswordRequest return")
    public void testGetUserChangePasswordRequest() throws IOException {
        when(mockUserInput.chooseUpdateOperation()).thenReturn("PASSWORD");
        when(mockUserInput.chooseUserToUpdate()).thenReturn("exampleUser");
        when(mockUserInput.getNewPassword()).thenReturn("newPassword");

        Request request = factory.getUpdateRequest();

        UserChangePasswordRequest userChangePasswordRequest = (UserChangePasswordRequest) request;
        assertEquals("PASSWORD", userChangePasswordRequest.getCommand());
        assertEquals("exampleUser", userChangePasswordRequest.getUserToUpdate());
        assertEquals("newPassword", userChangePasswordRequest.getNewPassword());
    }

    @Test
    @DisplayName("Should test UserRemoveRequest return")
    public void testGetUserRemoveRequest() throws IOException {
        when(mockUserInput.chooseUpdateOperation()).thenReturn("REMOVE");
        when(mockUserInput.chooseUserToUpdate()).thenReturn("exampleUser");

        Request request = factory.getUpdateRequest();

        UserRemoveRequest userRemoveRequest = (UserRemoveRequest) request;
        assertEquals("REMOVE", userRemoveRequest.getCommand());
        assertEquals("exampleUser", userRemoveRequest.getUserToUpdate());
    }

    @Test
    @DisplayName("Should test UserChangeRoleRequest return")
    public void testGetUserChangeRoleRequest() throws IOException {
        when(mockUserInput.chooseUpdateOperation()).thenReturn("ROLE");
        when(mockUserInput.chooseUserToUpdate()).thenReturn("exampleUser");
        when(mockUserInput.chooseRole()).thenReturn(User.Role.ADMIN);

        Request request = factory.getUpdateRequest();

        UserChangeRoleRequest userChangeRoleRequest = (UserChangeRoleRequest) request;
        assertEquals("ROLE", userChangeRoleRequest.getCommand());
        assertEquals("exampleUser", userChangeRoleRequest.getUserToUpdate());
        assertEquals(User.Role.ADMIN, userChangeRoleRequest.getNewRole());
    }

}

====================
FILE: LoginResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.auth.LoginResponse;
import user.manager.AuthManager;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class LoginResponseTest {
    AuthManager mockAuthManager;
    UserManager mockUserManager;
    LoginResponse loginResponse;
    private Request mockRequest;

    @BeforeEach
    void setUp() {
        mockAuthManager = mock(AuthManager.class);
        mockUserManager = mock(UserManager.class);
        loginResponse = new LoginResponse(mockAuthManager, mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test correct login response return")
    void testExecute() {
        when(mockRequest.getUsername()).thenReturn("testUser");
        when(mockRequest.getPassword()).thenReturn("testPassword");
        when(mockAuthManager.loginAndGetResponse("testUser", "testPassword", mockUserManager))
                .thenReturn("User login successful");

        String response = loginResponse.execute(mockRequest);

        assertEquals("User login successful", response);
    }
}

====================
FILE: LogoutResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.auth.LogoutResponse;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
class LogoutResponseTest {
    UserManager mockUserManager;
    LogoutResponse logoutResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        logoutResponse = new LogoutResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test correct logout response return")
    void testExecute() {
        when(mockUserManager.logoutAndGetResponse()).thenReturn("Logout succeeded");

        String response = logoutResponse.execute(mockRequest);

        assertEquals("Logout succeeded", response);
    }
}

====================
FILE: MailDeleteResponseTest.java

package resposne;

import mail.MailService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.mail.MailsDeleteResponse;
import shared.ResponseStatus;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class MailDeleteResponseTest {
    MailService mockMailService;
    MailsDeleteResponse mailsDeleteResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockMailService = mock(MailService.class);
        mailsDeleteResponse = new MailsDeleteResponse(mockMailService);
        mockRequest = mock(Request.class);
    }
    @Test
    @DisplayName("Should test mails deletion and return success response")
    void testExecute() {
        when(mockRequest.getBoxType()).thenReturn("UNREAD");

        String response = mailsDeleteResponse.execute(mockRequest);

        verify(mockMailService).deleteMails("UNREAD");
        assertEquals(ResponseStatus.MAIL_DELETION_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: MailReadResponseTest.java

package response.mail;

import mail.Mail;
import mail.MailService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import shared.ResponseStatus;
import user.credential.User;

import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class MailReadResponseTest {
    MailService mockMailService;
    MailsReadResponse mailsReadResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockMailService = mock(MailService.class);
        mailsReadResponse = new MailsReadResponse(mockMailService);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test mailbox empty response return when no mails")
    void testExecuteMailboxEmpty() {
        when(mockRequest.getBoxType()).thenReturn("UNREAD");
        when(mockMailService.getMails("UNREAD")).thenReturn(new ArrayList<>());

        String response = mailsReadResponse.execute(mockRequest);

        assertEquals(ResponseStatus.MAILBOX_EMPTY.getResponse(), response);
    }

    @Test
    @DisplayName("Should test mails return from inbox")
    void testExecuteWithMails() {
        when(mockRequest.getBoxType()).thenReturn("UNREAD");
        User sender = new User("senderName", "examplePassword", User.Role.USER);
        User recipient = new User("recipientName", "examplePassword", User.Role.USER);
        List<Mail> mails = List.of(new Mail(sender, recipient, "Example message", Mail.Status.UNREAD));
        when(mockMailService.getMails("UNREAD")).thenReturn(mails);

        String response = mailsReadResponse.execute(mockRequest);

        String expectedResponse = "UNREAD MAILS: \nFrom: senderName\n Message: Example message\n";
        assertEquals(expectedResponse, response);
    }
}

====================
FILE: MailWriteResponseTest.java

package resposne;

import mail.MailService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.mail.MailWriteResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class MailWriteResponseTest {
    MailService mockMailService;
    UserManager mockUserManager;
    MailWriteResponse mailWriteResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockMailService = mock(MailService.class);
        mockUserManager = mock(UserManager.class);
        mailWriteResponse = new MailWriteResponse(mockMailService, mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test recipient not found response return")
    void testExecuteRecipientNotFound() {
        when(mockRequest.getRecipient()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = mailWriteResponse.execute(mockRequest);

        assertEquals(ResponseStatus.SENDING_FAILED_RECIPIENT_NOT_FOUND.getResponse(), response);
    }

    @Test
    @DisplayName("Should test mailbox full response return")
    void testExecuteMailboxFull() {
        User recipient = new User("testUser", "password", User.Role.USER);
        when(mockRequest.getRecipient()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(recipient);
        when(mockMailService.isMailboxFull(recipient)).thenReturn(true);

        String response = mailWriteResponse.execute(mockRequest);

        assertEquals(ResponseStatus.SENDING_FAILED_BOX_FULL.getResponse(), response);
    }

    @Test
    @DisplayName("Should test message too long response return")
    void testExecuteMessageTooLong() {
        User recipient = new User("testUser", "password", User.Role.USER);
        when(mockRequest.getRecipient()).thenReturn("testUser");
        when(mockRequest.getMessage()).thenReturn("a".repeat(256));
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(recipient);

        String response = mailWriteResponse.execute(mockRequest);

        assertEquals(ResponseStatus.SENDING_FAILED_TO_LONG_MESSAGE.getResponse(), response);
    }

    @Test
    @DisplayName("Should test sending succeeded response return")
    void testExecuteSendingSucceeded() {
        User recipient = new User("testUser", "password", User.Role.USER);
        when(mockRequest.getRecipient()).thenReturn("testUser");
        when(mockRequest.getMessage()).thenReturn("Test message");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(recipient);
        when(mockMailService.isMailboxFull(recipient)).thenReturn(false);

        String response = mailWriteResponse.execute(mockRequest);

        verify(mockMailService).sendMail(recipient, "Test message");
        assertEquals(ResponseStatus.SENDING_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: RegisterResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.auth.RegisterResponse;
import user.manager.AuthManager;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class RegisterResponseTest {
    AuthManager mockAuthManager;
    UserManager mockUserManager;
    RegisterResponse registerResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockAuthManager = mock(AuthManager.class);
        mockUserManager = mock(UserManager.class);
        registerResponse = new RegisterResponse(mockAuthManager, mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test correct register response return")
    void testExecute() {
        when(mockRequest.getUsername()).thenReturn("testUser");
        when(mockRequest.getPassword()).thenReturn("testPassword");
        when(mockAuthManager.registerAndGetResponse("testUser", "testPassword", mockUserManager))
                .thenReturn("Registration successful");

        String response = registerResponse.execute(mockRequest);

        assertEquals("Registration successful", response);
    }
}

====================
FILE: ServerDetailsResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.server.ServerDetailsResponse;
import server.ServerDetails;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class ServerDetailsResponseTest {
    ServerDetails mockServerDetails;
    ServerDetailsResponse serverDetailsResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockServerDetails = mock(ServerDetails.class);
        serverDetailsResponse = new ServerDetailsResponse(mockServerDetails);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test server uptime return")
    void testExecuteUptime() {
        when(mockRequest.getCommand()).thenReturn("UPTIME");
        when(mockServerDetails.getUptime()).thenReturn(Map.of("Days", 1L, "Hours", 2L, "Minutes", 3L, "Seconds", 4L));

        String response = serverDetailsResponse.execute(mockRequest);

        String expectedResponse = "Uptime:\n1 days, 2 hours, 3 minutes, 4 seconds";
        assertEquals(expectedResponse, response);
    }

    @Test
    @DisplayName("Should test server info return")
    void testExecuteInfo() {
        when(mockRequest.getCommand()).thenReturn("INFO");
        when(mockServerDetails.getServerDetails()).thenReturn(Map.of("Version", "1.0.0", "Setup time", "2023-01-01 00:00:00"));

        String response = serverDetailsResponse.execute(mockRequest);

        String expectedResponse = "Server Info:\nVersion = 1.0.0\nSetup time = 2023-01-01 00:00:00\n";
        assertEquals(expectedResponse, response);
    }

    @Test
    @DisplayName("Should test server help return")
    void testExecuteHelp() {
        when(mockRequest.getCommand()).thenReturn("HELP");
        when(mockServerDetails.getCommands()).thenReturn(Map.of("Register", "Create a new user account", "Login", "Login to your account"));

        String response = serverDetailsResponse.execute(mockRequest);

        String expectedResponse = "Available Commands:\nRegister - Create a new user account\nLogin - Login to your account\n";
        assertEquals(expectedResponse, response);
    }
}

====================
FILE: UserPasswordChangeResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.user.UserPasswordChangeResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class UserPasswordChangeResponseTest {
    UserManager mockUserManager;
    UserPasswordChangeResponse userPasswordChangeResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        userPasswordChangeResponse = new UserPasswordChangeResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test authorization failed response return")
    void testExecuteAuthorizationFailed() {
        when(mockUserManager.isUserAdmin()).thenReturn(false);

        String response = userPasswordChangeResponse.execute(mockRequest);

        assertEquals(ResponseStatus.AUTHORIZATION_FAILED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test user not found response return")
    void testExecuteUserNotFound() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = userPasswordChangeResponse.execute(mockRequest);

        assertEquals(ResponseStatus.FAILED_TO_FIND_USER.getResponse(), response);
    }

    @Test
    @DisplayName("Should test operation succeeded response return")
    void testExecuteOperationSucceeded() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        User mockUser = mock(User.class);
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);
        when(mockRequest.getNewPassword()).thenReturn("newPassword");

        String response = userPasswordChangeResponse.execute(mockRequest);

        verify(mockUserManager).changePassword(mockUser, "newPassword");
        assertEquals(ResponseStatus.OPERATION_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: UserRemoveResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.user.UserRemoveResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class UserRemoveResponseTest {
    UserManager mockUserManager;
    UserRemoveResponse userRemoveResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        userRemoveResponse = new UserRemoveResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test authorization failed response return")
    void testExecuteAuthorizationFailed() {
        when(mockUserManager.isUserAdmin()).thenReturn(false);

        String response = userRemoveResponse.execute(mockRequest);

        assertEquals(ResponseStatus.AUTHORIZATION_FAILED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test user not found response return")
    void testExecuteUserNotFound() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = userRemoveResponse.execute(mockRequest);

        assertEquals(ResponseStatus.FAILED_TO_FIND_USER.getResponse(), response);
    }

    @Test
    @DisplayName("Should test operation succeeded response return")
    void testExecuteOperationSucceeded() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        User mockUser = mock(User.class);
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);

        String response = userRemoveResponse.execute(mockRequest);

        verify(mockUserManager).removeUser(mockUser);
        assertEquals(ResponseStatus.OPERATION_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: UserRemoveTestResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.user.UserRemoveResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;
class UserRemoveTestResponseTest {
    UserManager mockUserManager;
    UserRemoveResponse userRemoveResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        userRemoveResponse = new UserRemoveResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test authorization failed response return")
    void testExecuteAuthorizationFailed() {
        when(mockUserManager.isUserAdmin()).thenReturn(false);

        String response = userRemoveResponse.execute(mockRequest);

        assertEquals(ResponseStatus.AUTHORIZATION_FAILED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test return user not found response return")
    void testExecuteUserNotFound() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = userRemoveResponse.execute(mockRequest);

        assertEquals(ResponseStatus.FAILED_TO_FIND_USER.getResponse(), response);
    }

    @Test
    @DisplayName("Should test operation succeeded response return")
    void testExecuteOperationSucceeded() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        User mockUser = mock(User.class);
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);

        String response = userRemoveResponse.execute(mockRequest);

        verify(mockUserManager).removeUser(mockUser);
        assertEquals(ResponseStatus.OPERATION_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: UserRoleChangeResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.user.UserRoleChangeResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class UserRoleChangeResponseTest {
    UserManager mockUserManager;
    UserRoleChangeResponse userRoleChangeResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        userRoleChangeResponse = new UserRoleChangeResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test authorization failed response return")
    void testExecuteAuthorizationFailed() {
        when(mockUserManager.isUserAdmin()).thenReturn(false);

        String response = userRoleChangeResponse.execute(mockRequest);

        assertEquals(ResponseStatus.AUTHORIZATION_FAILED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test user not found response return")
    void testExecuteUserNotFound() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = userRoleChangeResponse.execute(mockRequest);

        assertEquals(ResponseStatus.FAILED_TO_FIND_USER.getResponse(), response);
    }

    @Test
    @DisplayName("Should test role change succeeded response return")
    void testExecuteRoleChangeSucceeded() {
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        when(mockRequest.getUserToUpdate()).thenReturn("testUser");
        User mockUser = mock(User.class);
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);
        when(mockRequest.getNewRole()).thenReturn(User.Role.ADMIN);

        String response = userRoleChangeResponse.execute(mockRequest);

        verify(mockUserManager).changeUserRole(mockUser, User.Role.ADMIN);
        assertEquals(ResponseStatus.ROLE_CHANGE_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: UserSwitchResponseTest.java

package resposne;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import request.Request;
import response.user.UserSwitchResponse;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class UserSwitchResponseTest {
    UserManager mockUserManager;
    UserSwitchResponse userSwitchResponse;
    Request mockRequest;

    @BeforeEach
    void setUp() {
        mockUserManager = mock(UserManager.class);
        userSwitchResponse = new UserSwitchResponse(mockUserManager);
        mockRequest = mock(Request.class);
    }

    @Test
    @DisplayName("Should test user not found response return")
    void testExecuteUserNotFound() {
        when(mockRequest.getUserToSwitch()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(null);

        String response = userSwitchResponse.execute(mockRequest);

        assertEquals(ResponseStatus.SWITCH_FAILED.getResponse() + ": user not found", response);
    }

    @Test
    @DisplayName("Should test user not authorized response return")
    void testExecuteUserNotAuthorized() {
        User mockUser = mock(User.class);
        when(mockRequest.getUserToSwitch()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);
        when(mockUserManager.isUserAdmin()).thenReturn(false);

        String response = userSwitchResponse.execute(mockRequest);

        assertEquals(ResponseStatus.SWITCH_FAILED.getResponse() + ": user not authorized", response);
    }

    @Test
    @DisplayName("Should test switch succeeded to admin role user uresponse return")
    void testExecuteSwitchSucceededAdmin() {
        User mockUser = mock(User.class);
        when(mockRequest.getUserToSwitch()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        UserManager.ifSwitchedToAdminUser = true;

        String response = userSwitchResponse.execute(mockRequest);

        verify(mockUserManager).switchUser(mockUser);
        assertEquals(ResponseStatus.SWITCH_SUCCEEDED_USER_ROLE_ADMIN_ROLE.getResponse(), response);
    }

    @Test
    @DisplayName("Should test switch succeeded to non-admin role user response return")
    void testExecuteSwitchSucceededNonAdmin() {
        User mockUser = mock(User.class);
        when(mockRequest.getUserToSwitch()).thenReturn("testUser");
        when(mockUserManager.getUserByUsername("testUser")).thenReturn(mockUser);
        when(mockUserManager.isUserAdmin()).thenReturn(true);
        UserManager.ifSwitchedToAdminUser = false;
        UserManager.ifSwitchedToNonAdminUser = true;

        String response = userSwitchResponse.execute(mockRequest);

        verify(mockUserManager).switchUser(mockUser);
        assertEquals(ResponseStatus.SWITCH_SUCCEEDED_USER_NON_ADMIN_ROLE.getResponse(), response);
    }
}

====================
FILE: ServerConnectionTest.java

package server;

import java.io.BufferedReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ServerConnectionTest {
    ServerConnection handler;
    ServerSocket mockServerSocket;
    Socket mockClientSocket;
    BufferedReader mockInFromClient;
    PrintWriter mockOutToClient;

    @BeforeEach
    void setUp() {
        handler = new ServerConnection(5000);
        mockServerSocket = mock(ServerSocket.class);
        mockClientSocket = mock(Socket.class);
        mockInFromClient = mock(BufferedReader.class);
        mockOutToClient = mock(PrintWriter.class);
        handler.setClientSocket(mockClientSocket);
        handler.setServerSocket(mockServerSocket);
        handler.setOutToClient(mockOutToClient);
        handler.setInFromClient(mockInFromClient);
    }

    @AfterEach
    void closeDown()  {
        handler.closeConnections();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectWithClient() {
        when(mockClientSocket.isConnected()).thenReturn(true);
        handler.startServer();

        assertTrue(mockClientSocket.isConnected());
    }
}

====================
FILE: JsonConverterTest.java

package shared;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class JsonConverterTest {
    @Test
    @DisplayName("Should test message serializing to JSon")
    void testSerializeMessage() {
        String message = "test message";
        JsonConverter converter = new JsonConverter(message);
        String expectedFormat = "{\"message\":\"test message\"}\n<<END>>";

        // Test JSON serialization
        String serializedMessage = converter.serializeMessage();

        assertNotNull(serializedMessage);
        assertEquals(serializedMessage, expectedFormat);
    }

    @Test
    @DisplayName("Should test message deserializing from JSon")
    void testDeserializeMessage() {
        String message = "test message";
        JsonConverter converter = new JsonConverter(message);

        String serializedMessage = converter.serializeMessage();

        // Removing "\n<<END>>" from the end of JSon message
        String jsonWithoutEndTag = serializedMessage.replace("\n<<END>>", "");

        // Test JSON deserialization
        String deserializedMessage = converter.deserializeMessage(jsonWithoutEndTag);

        assertNotNull(deserializedMessage);
        assertEquals(message, deserializedMessage);
    }
}

====================
FILE: AuthManagerTest.java

package user;

import database.UserDAO;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.AuthManager;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class AuthManagerTest {
    UserManager userManager;
    AuthManager authManager;
    User user;
    UserDAO mockUserDAO;
    String username = "testUsername";
    String password = "testPassword";

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
        authManager = new AuthManager();
        user = new User(username, password, User.Role.USER);
        mockUserDAO = mock(UserDAO.class);
        userManager.setUserDAO(mockUserDAO);
    }

    @Test
    @DisplayName("Should test user registration response with non-existent user in database")
    void testRegisterAndGetResponse() {
        when(mockUserDAO.getUserFromDB(username)).thenReturn(null);

        String response = authManager.registerAndGetResponse(username, password, userManager);

        assertEquals(ResponseStatus.REGISTRATION_SUCCESSFUL.getResponse(), response);
    }

    @Test
    @DisplayName("Should test user registration response with existing user in database")
    void testRegisterAndGetResponse_UserExists() {
        when(mockUserDAO.getUserFromDB(username)).thenReturn(user);

        String response = authManager.registerAndGetResponse(username, password, userManager);

        assertEquals(ResponseStatus.REGISTRATION_FAILED_USER_EXISTS.getResponse(), response);
    }

    @Test
    @DisplayName("Should test user login response with existing user in database")
    void testLoginAndGetResponse() {
        when(mockUserDAO.getUserFromDB(username)).thenReturn(user);
        when(mockUserDAO.checkPasswordInDB(password, username)).thenReturn(true);

        String response = authManager.loginAndGetResponse(username, password, userManager);

        assertEquals(ResponseStatus.USER_LOGIN_SUCCEEDED.getResponse(), response);
        assertEquals(user, UserManager.currentLoggedInUser);
    }

    @Test
    @DisplayName("Should test user login response with incorrect password in database")
    void testLoginAndGetResponse_IncorrectPassword() {
        when(mockUserDAO.getUserFromDB(username)).thenReturn(user);
        when(mockUserDAO.checkPasswordInDB(username,password)).thenReturn(false);

        String response = authManager.loginAndGetResponse(username, password, userManager);

        assertEquals(ResponseStatus.LOGIN_FAILED_INCORRECT_PASSWORD.getResponse(), response);
        assertNotEquals(user, UserManager.currentLoggedInUser);
    }

    @Test
    @DisplayName("Should test user registration handling")
    void testHandleRegister() {
        doNothing().when(mockUserDAO).addUserToDB(user);
        when(mockUserDAO.getUserFromDB(username)).thenReturn(user);

        authManager.handleRegister(username, password, userManager);

        User userFromDB = userManager.getUserByUsername(username);
        assertEquals(user, userFromDB);
    }
    @Test
    @DisplayName("Should test user registration handling")
    void testHandleLogin() {
        authManager.handleLogin(user);

        assertFalse(!UserManager.currentLoggedInUser.equals(user));
        assertTrue(UserManager.currentLoggedInUser.equals(user));
    }

    @Test
    @DisplayName("Should test user registration handling")
    void testIfPasswordCorrect() {
        when(mockUserDAO.checkPasswordInDB(password, username)).thenReturn(true);

        boolean isCorrect = authManager.ifPasswordCorrect(password, user, userManager);

        assertFalse(!isCorrect);
        assertTrue(isCorrect);
    }
}



====================
FILE: UserMangerTest.java

package user;

import database.UserDAO;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.ResponseStatus;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class UserMangerTest {
    UserManager userManager;
    User user;
    UserDAO mockUserDAO;
    String username = "testUsername";
    String password = "testPassword";

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
        user = new User(username, password, User.Role.USER);
        mockUserDAO = mock(UserDAO.class);
        userManager.setUserDAO(mockUserDAO);
    }

    @Test
    @DisplayName("Should test user registration for the first time")
    void testGetUserByUsername() {
        when(mockUserDAO.getUserFromDB("testUser")).thenReturn(user);

        User foundUser = userManager.getUserByUsername("testUser");
        assertEquals(user, foundUser);
    }

    @Test
    @DisplayName("Should test user registration for the first time")
    void testPasswordChange() {
        String newPassword = "newPassword";
        when(mockUserDAO.getUserFromDB(password)).thenReturn(user);

        userManager.changePassword(user, newPassword);

        assertNotEquals(password, user.getPassword());
        assertEquals(newPassword, user.getPassword());
    }

    @Test
    @DisplayName("Should test user deletion")
    void testDeleteUser() {
        doNothing().when(mockUserDAO).removeUserFromDB(username);

        userManager.removeUser(user);

        User foundUser = userManager.getUserByUsername(username);
        assertNull(foundUser);
    }

    @Test
    @DisplayName("Should test user switch by admin")
    void testSwitchUser() {
        userManager.switchUser(user);

        assertEquals(user, UserManager.currentLoggedInUser);
        assertTrue(UserManager.ifSwitchedToNonAdminUser);
    }

    @Test
    @DisplayName("Should test user role change")
    void testChangeRole() {
        when(mockUserDAO.getUserFromDB(username)).thenReturn(user);

        userManager.changeUserRole(user, User.Role.ADMIN);

        assertEquals(User.Role.ADMIN, user.getRole());
    }

    @Test
    @DisplayName("Should test user switch by admin")
    void testLogoutAndGetResponse(){
        String response = userManager.logoutAndGetResponse();

        assertNull(UserManager.currentLoggedInUser);
        assertFalse(UserManager.ifSwitchedToNonAdminUser);
        assertEquals(ResponseStatus.LOGOUT_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: UserTest.java

package user;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import user.credential.User;

import static org.junit.jupiter.api.Assertions.*;

class UserTest {
    User user;
    @BeforeEach
    void setUp() {
        user = new User("testUser", "testPassword", User.Role.USER);
    }

    @Test
    @DisplayName("Should test password hashing")
    void testHashPassword() {
        user.hashPassword();

        assertTrue(BCrypt.checkpw("testPassword", user.getHashedPassword()));
    }
    @Test
    @DisplayName("Should test password setting")
    void testSetPassword() {
        user.setPassword("testPassword");

        assertNotNull(user.getPassword());
        assertEquals("testPassword", user.getPassword());
    }
}

