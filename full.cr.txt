====================
FILE: Client.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import request.*;
import shared.Screen;

/*
 * This class represents a client application for server communication.
 * It handles user login, sending requests, and interacting with a mailbox.
 */

@Log4j2
@Getter
@Setter
public class Client {
    private ClientConnection connection;
    private BufferedReader userInput;
    private static Gson gson;

    public static void main(String[] args) {
        Client client = new Client();
        client.handleServerCommunication();
    }

    public Client() {
        connection = new ClientConnection();
        gson = new Gson();
        userInput = new BufferedReader(new InputStreamReader(System.in));
        log.info("Client instance created");
    }

    public void handleServerCommunication() {
        try {
            log.info("Starting server communication");
            while(connection.isConnected()){
                printClientUI();
                String request = userInput.readLine();
                if (request == null || request.equalsIgnoreCase("EXIT")) {
                    connection.disconnect();
                    log.info("User exited the application");
                    return;
                }
                    handleRequest(request);
            }
        } catch (IOException ex) {
            log.error("Error in handling server communication: {}", ex.getMessage());
        }
    }

    public void handleRequest(String request) throws IOException {
        log.info("Handling user request: {}", request);
        try{
            RequestService requestService = new RequestService(connection);
            Request requestType = requestService.getRequest(request);

            if (requestType != null) {
                String jsonRequest = gson.toJson(requestType);
                connection.sendRequest(jsonRequest);
                log.info("User attempted to {}", request);
                connection.readResponse();
            } else {
                log.warn("Incorrect input from user: {}", request);
                System.out.println("Incorrect input. Please, try again");
            }
        } catch (IOException ex){
            log.error("Error handling request: {}", ex.getMessage());
        }
    }

    public void printClientUI(){
        if(!connection.isLoggedIn()) {
            Screen.printLoginMenu();
        } else {
            if(connection.isAuthorized()){
                Screen.printAdminMailBoxMenu();
            } else{
                Screen.printUserMailBoxMenu();
            }
        }
    }
}

====================
FILE: ClientConnection.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import shared.JsonConverter;

/*
 * The ClientConnection class manages the connection between the client and server.
 * It establishes, maintains, and handles communication through sockets.
 * Additionally, it manages login status and authorization checks.
 */

@Log4j2
@Getter
@Setter
public class ClientConnection {
    private final int PORT_NUMBER = 5000;
    private Socket clientSocket;
    private PrintWriter outToServer;
    private BufferedReader inFromServer;
    public static boolean loggedIn = false;
    private boolean isAuthorized = false;
    private boolean  isAdminSwitchedAndAuthorized = false;
    public static int connectionAttempts = 0;
    private boolean connected = false;
    private static ResponseMessage responseMsg;

    /*
     * The ClientConnection class is responsible for managing connections
     * Establishes connections with server, and handles the communication
     */

    public ClientConnection() {
        connectToServer();
        log.info("ClientConnection instance created");
    }

    public void connectToServer() {
        try {
            clientSocket = new Socket("localhost", PORT_NUMBER);
            outToServer = new PrintWriter(clientSocket.getOutputStream(), true);
            inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            connected = true;
            log.info("Connection with Server established on port {}", PORT_NUMBER);
        } catch (IOException ex) {
            log.error("Failed to establish connection with the server at port {}. Error: {}", PORT_NUMBER, ex.getMessage());
            retryConnection();
        }
    }

    public void retryConnection() {
        if (connectionAttempts >= 2) {
            log.error("Max reconnection attempts reached. Giving up");
            disconnect();
            return;
        }
        try {
            Thread.sleep(2000);
            log.info("Attempting to reconnect to the server...");
            Thread.sleep(5000);
            connectionAttempts++;
            connectToServer();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            log.warn("Reconnection attempt interrupted", ie);
        }
    }

    public void sendRequest(String request) {
        outToServer.println(request);
        log.info("Sent request to server: {}", request);
    }

    public void readResponse() throws IOException {
        try{
            String jsonResponse;
            log.info("Reading response from server");
            while (!(jsonResponse = inFromServer.readLine()).equals("<<END>>")) {
                String response = JsonConverter.deserializeMessage(jsonResponse);
                checkResponseStatus(response);
                System.out.println(JsonConverter.deserializeMessage(jsonResponse));
            }
        } catch (IOException ex){
            log.error("Error reading response: {}", ex.getMessage());
        }
    }

    // Checks the login update and role authorization
    public void checkResponseStatus(String response) {
        ResponseMessage operationMessage = ResponseMessage.fromString(response);
        System.out.println(operationMessage);
        switch (operationMessage) {
            case ADMIN_LOGIN_SUCCEEDED:
                loggedIn = true;
                isAuthorized = true;
                log.info("Admin login succeeded");
                break;
            case USER_LOGIN_SUCCEEDED:
                loggedIn = true;
                log.info("User login succeeded");
                break;
            case REGISTRATION_SUCCESSFUL:
                loggedIn = true;
                log.info("User registered succeeded");
                break;
            case LOGOUT_SUCCEEDED:
                loggedIn = false;
                isAuthorized = false;
                isAdminSwitchedAndAuthorized = false;
                log.info("User logout succeeded");
                break;
            case AUTHORIZATION_SUCCEEDED:
                isAuthorized = true;
                log.info("User authorization succeeded");
                break;
            case SWITCH_SUCCEEDED:
                isAuthorized = false;
                isAdminSwitchedAndAuthorized = true;
                log.info("Switch succeeded");
                break;
            default:
                log.info("No response required to action");
        }
    }

    public void disconnect() {
        try {
            if (outToServer != null) {
                outToServer.close();
            }
            if (inFromServer != null) {
                inFromServer.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            log.info("Disconnected from server");
        } catch (IOException ex) {
            log.error("Error during disconnection: {}", ex.getMessage());
        }
    }

    public boolean isLoggedIn() {
        return loggedIn;
    }

    public boolean isAuthorized() {
        return isAuthorized;
    }
    public boolean isConnected(){
        return connected;
    }
}

====================
FILE: AuthHandler.java

package handler.auth;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.UserManager;

/*
 * The AuthHandler class processes authentication requests such as REGISTER and LOGIN.
 * It interacts with the UserManager to handle these operations and generate appropriate responses.
 */

@Log4j2
public class AuthHandler {
     public String getResponse(String requestCommand, String username, String password, UserManager userManager)  {
         log.info("Processing authentication request: {}", requestCommand);
         switch (requestCommand) {
            case "REGISTER":
                return userManager.registerAndGetResponse(username, password);
            case "LOGIN":
                return userManager.loginAndGetResponse(username, password);
             default:
                 log.warn("Unknown request: {}", requestCommand);
                 return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }
}

====================
FILE: LogoutHandler.java

package handler.auth;

import lombok.extern.log4j.Log4j2;
import user.UserManager;

@Log4j2
public class LogoutHandler {
    public String getResponse(UserManager userManager)  {
        log.info("Attempting to log out user: {}", UserManager.currentLoggedInUser.getUsername());
        return userManager.getLogoutResponse();
    }
}

====================
FILE: MailboxHandler.java

package handler.mail;

import java.io.IOException;
import java.util.List;

import lombok.extern.log4j.Log4j2;
import mail.Mail;
import mail.MailService;
import shared.ResponseMessage;

/*
 * The MailboxHandler class handles mailbox operations such as reading and emptying mailboxes.
 * It uses the MailService to perform these operations and generate appropriate responses.
 */
@Log4j2
public class MailboxHandler {
    private MailService mailService = new MailService();

    public String getResponse(String mailboxOperation, String boxType) throws IOException {
        log.info("Processing mailbox operation: {}", mailboxOperation);
        switch (mailboxOperation) {
            case "READ":
                return getReadResponse(boxType);
            case "EMPTY":
                return getEmptyMailboxResponse(boxType);
            default:
                log.warn("Unknown mail operation: {}", mailboxOperation);
                return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }

    private String getReadResponse(String boxType) {
        log.info("Reading mails from box: {}", boxType);
        List<Mail> mailsToRead = mailService.getMailsToRead(boxType);

        if (mailsToRead.isEmpty()) {
            return ResponseMessage.MAILBOX_EMPTY.getResponse();
        }

        StringBuilder response = new StringBuilder();
        for (Mail mail : mailsToRead) {
            response.append("From ")
                    .append(mail.getSender().getUsername())
                    .append("\n Message: ")
                    .append(mail.getMessage());
        }

        mailService.markMailsAsRead(boxType);
        return response.toString();
    }

    private String getEmptyMailboxResponse(String boxType){
        log.info("Emptying mails from box: {}", boxType);
        mailService.deleteEmails(boxType);
        return ResponseMessage.MAIL_DELETION_SUCCEEDED.getResponse();
    }
}

====================
FILE: WriteHandler.java

package handler.mail;

import java.io.IOException;

import lombok.extern.log4j.Log4j2;
import mail.Mail;
import mail.MailService;
import shared.ResponseMessage;
import user.User;
import user.UserManager;

/*
 * The WriteHandler class processes requests to send mail.
 * It interacts with the MailService and UserManager to send emails and handle related validations.
 */

@Log4j2
public class WriteHandler {
    private MailService mailService = new MailService();
    public String getResponse(String username, String message, UserManager userManager) throws IOException {
        log.info("Attempting to send mail to user: {}", username);
        User recipient = userManager.getUserByUsername(username);

        if (recipient != null) {
            log.warn("Mail sending failed, recipient not found: {}", username);
            return ResponseMessage.SENDING_FAILED_RECIPIENT_NOT_FOUND.getResponse();
        }

        if(recipient.getMailBox().ifUnreadBoxFull()) {
            log.warn("Mail sending failed, recipient's {} mailbox is full: ", username);
            return ResponseMessage.SENDING_FAILED_BOX_FULL.getResponse();
        }

        if(message.length() >= 255) {
            log.warn("Mail sending failed, message too long for recipient: {}", username);
            return ResponseMessage.SENDING_FAILED_TO_LONG_MESSAGE.getResponse();
        }

        mailService.sendMail(new Mail(UserManager.currentLoggedInUser, recipient, message));
        log.info("Mail sent successfully to: {}", username);
        return ResponseMessage.SENDING_SUCCEEDED.getResponse();
    }
}

====================
FILE: ServerDetailsHandler.java

package handler.server;

import lombok.extern.log4j.Log4j2;
import server.ServerDetails;
import shared.ResponseMessage;

/*
 * The ServerDetailsHandler class provides responses for server information requests.
 * It can return server uptime, version, and available commands.
 */

@Log4j2
public class ServerDetailsHandler {
    private final ServerDetails serverInfo = new ServerDetails();

    public String getResponse(String requestCommand) {
        log.info("Received info request command: {}", requestCommand);
        return getFormattedServerInfo(requestCommand);
    }

    private String getFormattedServerInfo(String request) {
        StringBuilder builder = new StringBuilder();
        switch (request.toUpperCase()) {
            case "UPTIME":
                builder.append("Uptime:\n");
                builder.append(String.format("%d days, %d hours, %d minutes, %d seconds",
                        serverInfo.getUptime().get("Days"),
                        serverInfo.getUptime().get("Hours"),
                        serverInfo.getUptime().get("Minutes"),
                        serverInfo.getUptime().get("Seconds")));
                builder.toString();
            case "INFO":
                builder.append("Server Info:\n");
                serverInfo.getServerDetails().forEach((key, value) -> builder.append(key).append(" = ").append(value).append("\n"));
                builder.toString();
            case "HELP":
                builder.append("Available Commands:\n");
                serverInfo.getCommands().forEach((key, value) -> builder.append(key).append(" - ").append(value).append("\n"));
                return builder.toString();
            default:
                log.warn("Unknown server info request: {}", request);
                return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }
}

====================
FILE: AccountUpdateHandler.java

package handler.user;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.User;
import user.UserManager;

/*
 * The AccountUpdateHandler class handles account update requests such as changing passwords, deleting users, and changing user roles.
 * It ensures the current user is authorized to perform these operations.
 */

@Log4j2
public class AccountUpdateHandler {

    /*
     * Attempts to change the password for the specified user.
     * Ensures the current user is an admin and the target user exists.
     */
    public String getChangePasswordResponse(String username, String newPassword, UserManager userManager) {
        log.info("Attempting to change password for user: {}", username);
        if (!userManager.ifCurrentUserAdmin()) {
            log.warn("Authorization failed for password change for user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }

        User user = userManager.getUserByUsername(username);

        if (user == null) {
            log.warn("Failed to find user: {}", username);
            return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
        }

        userManager.getAdmin().changePassword(user, newPassword);
        log.info("Password changed successfully for user: {}", username);
        return ResponseMessage.OPERATION_SUCCEEDED.getResponse();
    }

    /*
     * Attempts to delete the specified user account.
     * Ensures the current user is an admin and the target user exists.
     */
    public String getUserDeleteResponse(String username, UserManager userManager) {
        log.info("Attempting to delete user: {}", username);
        if (!userManager.ifCurrentUserAdmin()) {
            log.warn("Authorization failed for deleting user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }

        User user = userManager.getUserByUsername(username);

        if (user == null) {
            log.warn("Failed to find user: {}", username);
            return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
        }

        userManager.getAdmin().deleteUser(user);
        log.info("User account deletion succeeded: {}", username);
        return ResponseMessage.OPERATION_SUCCEEDED.getResponse();
    }

    /*
     * Attempts to change the role for the specified user.
     * Ensures the current user is an admin and the target user exists.
     */
    public String getChangeRoleResponse(String username, User.Role role, UserManager userManager) {
        log.info("Attempting to change role for user: {}", username);
        if (!userManager.ifCurrentUserAdmin()) {
            log.warn("Authorization failed for changing role for user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }

        User user = userManager.getUserByUsername(username);

        if (user == null) {
            log.warn("Failed to find user: {}", username);
            return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
        }

        userManager.getAdmin().changeUserRole(user, role);
        log.info("Role change succeeded: {}", username);
        return ResponseMessage.ROLE_CHANGE_SUCCEEDED.getResponse();
    }
}

====================
FILE: AdminSwitchHandler.java

package handler.user;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.User;
import user.UserManager;

/*
 * The AdminSwitchHandler class handles requests to switch the current user to an admin user.
 * It verifies the current user is authorized to perform the switch and updates the UserManager accordingly.
 */

@Log4j2
public class AdminSwitchHandler {
    public String getResponse(String username, UserManager userManager) {
        log.info("Attempting to switch admin to user: {}", username);
        User user = userManager.getUserByUsername(username);

        if (user == null) {
            log.warn("User not found: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse() + ": user not found";
        }

        if (!userManager.ifCurrentUserAdmin()) {
            log.warn("Non-admin user attempted switch: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse() + ": non-admin user";
        }

        userManager.getAdmin().switchUser(user);

        if (UserManager.ifAdminSwitched) {
            log.info("Switch succeeded: {}", username);
            return ResponseMessage.SWITCH_SUCCEEDED.getResponse();
        } else {
            log.warn("Switch failed: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse();
        }
    }
}

====================
FILE: Mail.java

package mail;

import lombok.Getter;
import lombok.Setter;
import user.User;
@Getter
@Setter
public class Mail {
    private User sender;
    private User recipient;
    private String message;
    private int messageLength;

    public Mail(User sender, User recipient, String message) {
        this.sender = sender;
        this.recipient = recipient;
        this.message = message;
        this.messageLength = message.length();
    }
}

====================
FILE: MailBox.java

package mail;

import java.util.ArrayList;
import java.util.List;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MailBox {
    private List<Mail> openedBox;
    private List<Mail> unreadBox;
    private List<Mail> sentBox;
    private final int BOXLIMIT = 5;

    public MailBox() {
        openedBox = new ArrayList<>();
        unreadBox = new ArrayList<>();
        sentBox = new ArrayList<>();
    }

    public boolean ifUnreadBoxFull(){
        return unreadBox.size() >= BOXLIMIT;
    }
}

====================
FILE: MailService.java

package mail;

import lombok.extern.log4j.Log4j2;
import user.UserManager;
import java.util.List;

@Log4j2
public class MailService {
    public void sendMail(Mail mail) {
        mail.getRecipient().getMailBox().getUnreadBox().add(mail);
        mail.getSender().getMailBox().getSentBox().add(mail);
        log.info("Mail successfully sent to {}", mail.getRecipient().getUsername());
    }

    /*
     * Retrieves a list of mails based on the specified mailbox type (e.g., OPENED, UNREAD, SENT).
     * Logs the retrieval operation and handles invalid mailbox types.
     */
    public List<Mail> getMailsToRead(String boxType) {
        log.info("Getting mails to read for mailbox: {}", boxType);
        List<Mail> mailsToRead = getMailListByType(boxType);
        if (mailsToRead != null) {
            log.info("{} mails returned for mailbox {}", boxType, UserManager.currentLoggedInUser.getUsername());
        } else {
            log.warn("Invalid mailbox type requested: {}", boxType);
        }
        return mailsToRead;
    }

    /*
     * Deletes all emails from the specified mailbox type.
     * Logs the deletion operation and handles invalid mailbox types.
     */
    public void deleteEmails(String boxType) {
        log.info("Deleting mails from box: {}", boxType);
        List<Mail> mailList = getMailListByType(boxType);
        if (mailList != null) {
            mailList.clear();
            log.info("{} mails deleted successfully for user {}", boxType, UserManager.currentLoggedInUser.getUsername());
        } else {
            log.warn("Attempted to empty non-existent mailbox type: {}", boxType);
        }
    }

    /*
     * Retrieves the list of mails
     * Handles the different mailbox types: OPENED, UNREAD, SENT.
     */
    private List<Mail> getMailListByType(String boxType) {
        MailBox mailBox = UserManager.currentLoggedInUser.getMailBox();
        switch (boxType.toUpperCase()) {
            case "OPENED":
                return mailBox.getOpenedBox();
            case "UNREAD":
                return mailBox.getUnreadBox();
            case "SENT":
                return mailBox.getSentBox();
            default:
                log.error("Unknown mailbox type requested: {}", boxType);
                return null;
        }
    }

    /*
     * Marks all unread mails as read by moving them to the opened box and clearing the unread box.
     * Logs the operation and ensures the 'sent' mails are not marked as read.
     */
    public void markMailsAsRead(String boxType){
        log.info("Marking mails as read for mailbox: {}", boxType);
        if(!boxType.equals("SENT")){
            List<Mail> unreadMails = UserManager.currentLoggedInUser.getMailBox().getUnreadBox();
            for(Mail mail: unreadMails){
                UserManager.currentLoggedInUser.getMailBox().getOpenedBox().add(mail);
            }
            UserManager.currentLoggedInUser.getMailBox().getUnreadBox().clear();
            log.info("Marked all unread mails as read for user {}", UserManager.currentLoggedInUser.getUsername());
        } else {
        log.warn("Attempted to mark 'sent' mails as read, operation not allowed");
        }
    }
}

====================
FILE: Request.java

package request;

import lombok.Getter;
import lombok.Setter;
import user.User;

@Getter
@Setter
public class Request {
    String requestCommand;
    String username;
    String password;
    String recipient;
    String message;
    String boxOperation;
    String mailbox;
    String updateOperation;
    String userToUpdate;
    String newPassword;
    String userToSwitch;
    User.Role newRole;
}


====================
FILE: RequestFactory.java

package request;

import lombok.extern.log4j.Log4j2;
import user.User;

/*
 * The RequestFactory class creates different types of Request objects based on the command and parameters provided.
 * It includes methods for creating authentication, server details, mailbox, and account update requests.
 */

@Log4j2
public class RequestFactory {
    Request request;

    public RequestFactory() {
        this.request = new Request();
    }

    public Request createAuthRequest(String requestCommand, String username, String password) {
        request.requestCommand = requestCommand;
        request.username = username;
        request.password = password;
        log.info("AuthRequest created for user: {}", username);
        return request;
    }

    public Request createServerDetailsRequest(String requestCommand) {
        request.requestCommand = requestCommand;
        log.info("ServerDetailsRequest created with command: {}", requestCommand);
        return request;
    }

    public Request createLogoutRequest(String requestCommand) {
        request.requestCommand = requestCommand;
        log.info("LogoutRequest created with command: {}", requestCommand);
        return request;
    }

    public Request createWriteRequest(String requestCommand, String recipient, String message) {
        request.requestCommand = requestCommand;
        request.recipient = recipient;
        request.message = message;
        log.info("WriteRequest created for recipient: {}", recipient);
        return request;
    }

    public Request createMailBoxRequest(String requestCommand, String boxOperation, String mailbox) {
        request.requestCommand = requestCommand;
        request.boxOperation = boxOperation;
        request.mailbox = mailbox;
        log.info("MailBoxRequest created with operation: {} for mailbox: {}", boxOperation, mailbox);
        return request;
    }

    public Request createAdminChangePasswordRequest(String updateOperation, String userToUpdate, String newPassword) {
        request.requestCommand = updateOperation;
        request.userToUpdate = userToUpdate;
        request.newPassword = newPassword;
        log.info("AdminChangePasswordRequest created for user: {}", userToUpdate);
        return request;
    }

    public Request createAdminDeleteUserRequest(String updateOperation, String userToDelete) {
        request.requestCommand = updateOperation;
        request.userToUpdate = userToDelete;
        log.info("AdminDeleteUserRequest created for user: {}", userToDelete);
        return request;
    }

    public Request createAdminChangeRoleRequest(String updateOperation, String userToUpdate, User.Role role) {
        request.requestCommand = updateOperation;
        request.userToUpdate = userToUpdate;
        request.newRole = role;
        log.info("AdminChangeRoleRequest created for user: {} with new role: {}", userToUpdate, role);
        return request;
    }

    public Request createAdminSwitchUserRequest(String requestCommand, String username) {
        request.requestCommand = requestCommand;
        request.userToSwitch = username;
        log.info("AdminSwitchUserRequest created for user: {}", username);
        return request;
    }
}

====================
FILE: RequestService.java

package request;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import client.ClientConnection;
import lombok.extern.log4j.Log4j2;
import shared.UserInteraction;
import user.User;

@Log4j2
public class RequestService {

    private BufferedReader userInput;
    UserInteraction userInteraction;
    ClientConnection connection;
    RequestFactory factory = new RequestFactory();

    public RequestService(ClientConnection clientConnection) {
        this.connection = clientConnection;
        this.userInput = new BufferedReader(new InputStreamReader(System.in));
        this.userInteraction = new UserInteraction(userInput);
        log.info("RequestFactory instance created");
    }

    /*
     * Creates a request based on the current connection state (logged in or not).
     * Delegates to the appropriate menu request handler.
     */
    public Request getRequest(String requestCommand) throws IOException {
        log.info("Creating request for command: {}", requestCommand);
        if(!connection.isLoggedIn()){
            return getLoginMenuRequest(requestCommand);
        } else {
            return getMailboxMenuRequest(requestCommand);
        }
    }

    /*
     * Handles requests from the login menu.
     * Prompts the user for necessary information and creates the appropriate request.
     */
    public Request getLoginMenuRequest(String requestCommand) throws IOException {
        switch (requestCommand.toUpperCase()) {
            case "REGISTER":
            case "LOGIN":
                String username = userInteraction.getUsername();
                String password = userInteraction.getPassword();
                return factory.createAuthRequest(requestCommand, username, password);
            case "HELP":
            case "INFO":
            case "UPTIME":
                return factory.createServerDetailsRequest(requestCommand);
            case "LOGOUT":
                return factory.createLogoutRequest(requestCommand);
            default:
                log.warn("Unknown login menu request: {}", requestCommand);
                return null;
        }
    }

    /*
     * Handles requests from the mailbox menu.
     * Prompts the user for necessary information and creates the appropriate request.
     */
    public Request getMailboxMenuRequest(String requestCommand) throws IOException {
        switch (requestCommand.toUpperCase()){
            case "WRITE":
                String recipient = userInteraction.getRecipient();
                String message = userInteraction.getMessage();
                return factory.createWriteRequest(requestCommand, recipient, message);
            case "MAILBOX":
                String boxOperation = userInteraction.chooseBoxOperation();
                String mailbox = userInteraction.chooseMailBox();
                return factory.createMailBoxRequest(requestCommand, boxOperation, mailbox);
            case "UPDATE":
                return getAccountUpdateRequest();
            case "SWITCH":
                String userToSwitch = userInteraction.getUserToSwitch();
                return factory.createAdminSwitchUserRequest(requestCommand, userToSwitch);
            case "LOGOUT":
                return factory.createLogoutRequest(requestCommand);
            default:
                log.warn("Unknown mailbox menu request: {}", requestCommand);
                return null;
        }
    }

    /*
     * Creates an account update request (password change, delete user, change role).
     * Ensures the current user is authorized to perform the update.
     * Prompts the user for necessary information and creates the appropriate request.
     */
    public Request getAccountUpdateRequest() throws IOException {
        log.info("Creating account update request");
        if (connection.isAuthorized()) {
            log.info("Authorization succeeded");
            String updateOperation = userInteraction.chooseUpdateOperation();
            String userToUpdate = userInteraction.chooseUserToUpdate();
            switch (updateOperation) {
                case "PASSWORD":
                    String newPassword = userInteraction.getNewPassword();
                    return factory.createAdminChangePasswordRequest(updateOperation, userToUpdate, newPassword);
                case "DELETE":
                    return factory.createAdminDeleteUserRequest(updateOperation, userToUpdate);
                case "ROLE":
                    User.Role newRole = userInteraction.chooseRole();
                    return factory.createAdminChangeRoleRequest(updateOperation, userToUpdate, newRole);
                default:
                    log.warn("Unknown update operation: {}", updateOperation);
                    return null;
            }

        }
        log.info("Authorization failed");
        return null;
    }
}

====================
FILE: Server.java

package server;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class Server {
    private static final int PORT = 5000;
    public static void main(String[] args) {
        log.info("Starting server on port {}", PORT);
        ServerConnection connectionHandler = new ServerConnection(PORT);
        connectionHandler.startServer();

        ServerRequestService logicHandler = new ServerRequestService(
                connectionHandler.getOutToClient(),
                connectionHandler.getInFromClient());

        logicHandler.handleClientRequest();

        connectionHandler.closeConnections();
    }
}

====================
FILE: ServerConnection.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Date;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

/*
 * The ServerConnection class is responsible for managing server connections.
 * It starts the server, establishes connections with clients, and handles communication streams.
 */

@Log4j2
@Getter
@Setter
public class ServerConnection {
    private int port;
    public static Date serverTimeCreation;
    private ServerSocket serverSocket;
    private Socket clientSocket;
    private BufferedReader inFromClient;
    private PrintWriter outToClient;

    public ServerConnection(int port) {
        this.port = port;
    }

    public void startServer(){
        try{
            log.info("Starting server on port {}", port);
            serverTimeCreation = new Date();
            serverSocket = new ServerSocket(port);
            log.info("Server socket created on port {}", port);
            clientSocket = serverSocket.accept();
            log.info("Connection with client established");
            inFromClient = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            outToClient = new PrintWriter(clientSocket.getOutputStream(), true);
        } catch (IOException ex){
            log.error("Error starting server on port {}: {}", port, ex.getMessage());
        }
    }

    public BufferedReader getInFromClient() {
        return inFromClient;
    }

    public PrintWriter getOutToClient() {
        return outToClient;
    }

    public void closeConnections() {
        try {
            log.info("Closing server and client connections");
            if (inFromClient != null) {
                inFromClient.close();
            }
            if (outToClient != null) {
                outToClient.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            if (serverSocket != null) {
                serverSocket.close();
            }
            log.info("Server and client connections closed");
        } catch (IOException ex) {
            log.error("Error closing connections: {}", ex.getMessage());
        }
    }
}

====================
FILE: ServerDetails.java

package server;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

/*
 * The ServerDetails class provides information about the server.
 * It includes server version, available commands, and server uptime.
 */

@Getter
@Setter
@Log4j2
public class ServerDetails {
    private final String VERSION = "1.0.0";
    private Map<String, String> commands = new LinkedHashMap<>();
    private Map<String, String> serverDetails = new LinkedHashMap<>();
    private Map<String, Long> uptime = new LinkedHashMap<>();

    public ServerDetails() {
        log.info("Initializing server details");
        setCommands();
        setServerDetails();
        setUptime();
    }

   public void setUptime(){
       log.info("Setting server uptime");
       Date currentTime = new Date();
       long uptimeInMillis = currentTime.getTime() - ServerConnection.serverTimeCreation.getTime();

       long days = TimeUnit.MILLISECONDS.toDays(uptimeInMillis);
       long hours = TimeUnit.MILLISECONDS.toHours(uptimeInMillis) % 24;
       long minutes = TimeUnit.MILLISECONDS.toMinutes(uptimeInMillis) % 60;
       long seconds = TimeUnit.MILLISECONDS.toSeconds(uptimeInMillis) % 60;

       uptime.put("Days", days);
       uptime.put("Hours", hours);
       uptime.put("Minutes", minutes);
       uptime.put("Seconds", seconds);

       log.info("Server uptime set to: {} days, {} hours, {} minutes, {} seconds", days, hours, minutes, seconds);
    }

    public void setCommands() {
        log.info("Setting server commands");
        commands.put("Login", "Login to your account");
        commands.put("Register", "Create a new user account");
        commands.put("Help", "All commands list");
        commands.put("Uptime", "Check server uptime");
        commands.put("Info", "Server version and date");
        commands.put("Exit", "Stop server and client");

        log.info("Server commands set: {}", commands.keySet());
    }

    public void setServerDetails() {
        log.info("Setting server details");
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
        String setupTimeFormatted = dateFormat.format(ServerConnection.serverTimeCreation);
        serverDetails.put("Version", VERSION);
        serverDetails.put("Setup time", setupTimeFormatted);

        log.info("Server details set: {}", serverDetails);
    }
}

====================
FILE: ServerRequestService.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

import com.google.gson.Gson;
import handler.auth.AuthHandler;
import handler.auth.LogoutHandler;
import handler.mail.MailboxHandler;
import handler.mail.WriteHandler;
import handler.server.ServerDetailsHandler;
import handler.user.AccountUpdateHandler;
import handler.user.AdminSwitchHandler;
import lombok.extern.log4j.Log4j2;
import request.Request;
import shared.JsonConverter;
import user.UserManager;

 /*
  * The ServerRequestService class is responsible for handling various client requests and processing server-side logic
  * It manages user authentication, mail operations, user account updates, account switch, and server information
  */

@Log4j2
public class ServerRequestService {
    private final PrintWriter outToClient;
    private final BufferedReader inFromClient;
    private final UserManager userManager;
    private Gson gson;
    private JsonConverter jsonResponse;
    private AuthHandler authHandler;
    private ServerDetailsHandler serverInfoHandler;
    private MailboxHandler mailboxHandler;
    private AccountUpdateHandler updateHandler;
    private WriteHandler writeHandler;
    private LogoutHandler logoutHandler;
    private AdminSwitchHandler switchHandler;
    public ServerRequestService(PrintWriter outToClient, BufferedReader inFromClient) {
        this.outToClient = outToClient;
        this.inFromClient = inFromClient;
        this.userManager = new UserManager();
        this.gson = new Gson();
        this.authHandler = new AuthHandler();
        this.serverInfoHandler = new ServerDetailsHandler();
        this.mailboxHandler = new MailboxHandler();
        this.updateHandler = new AccountUpdateHandler();
        this.writeHandler = new WriteHandler();
        this.switchHandler = new AdminSwitchHandler();
        this.logoutHandler = new LogoutHandler();
    }

    public void handleClientRequest() {
        String request;
        String response;
        try {
            while ((request = inFromClient.readLine()) != null) {
                Request req = getParseRequest(request);
                String requestCommand = req.getRequestCommand().toUpperCase();
                log.info("Handling request command: {}", requestCommand);
                switch (requestCommand) {
                    case "REGISTER":
                    case "LOGIN":
                        response = authHandler.getResponse(requestCommand, req.getUsername(), req.getPassword(), userManager);
                        break;
                    case "HELP":
                    case "INFO":
                    case "UPTIME":
                        response = serverInfoHandler.getResponse(requestCommand);
                        break;
                    case "WRITE":
                        response = writeHandler.getResponse(req.getRecipient(), req.getMessage(), userManager);
                        break;
                    case "MAILBOX":
                        response = mailboxHandler.getResponse(req.getBoxOperation(),req.getMailbox());
                        break;
                    case "PASSWORD":
                        response = updateHandler.getChangePasswordResponse(req.getUserToUpdate(), req.getNewPassword(), userManager);
                        break;
                    case "DELETE":
                        response = updateHandler.getUserDeleteResponse(req.getUserToUpdate(), userManager);
                        break;
                    case "ROLE":
                        response = updateHandler.getChangeRoleResponse(req.getUserToUpdate(), req.getNewRole(), userManager);
                        break;
                    case "SWITCH":
                        response = switchHandler.getResponse(req.getUserToSwitch(), userManager);
                        break;
                    case "LOGOUT":
                        response = logoutHandler.getResponse(userManager);
                        break;
                    default:
                        log.warn("Unknown request command: {}", requestCommand);
                        response = "Unknown request command";
                        break;
                }
                sendResponse(response);
                log.info("Completed processing request command: {}", requestCommand);
            }
        } catch (IOException ex) {
            log.error("IOException occurred while processing the request: {}. Error: ", ex.getMessage());
        }
    }

    public Request getParseRequest(String request){
        log.info("Parsing request: {}", request);
        return gson.fromJson(request, Request.class);
    }
    public void sendResponse(String response){
        jsonResponse = new JsonConverter(response);
        String json = jsonResponse.serializeMessage();
        outToClient.println(json);
        log.info("Response sent: {}", json);
    }
}

====================
FILE: JsonConverter.java

package shared;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;

import java.io.FileWriter;
import java.io.IOException;

import lombok.extern.log4j.Log4j2;
import user.User;

/*
  * The JsonConverter class provides utilities for converting objects to and from JSON
  * It includes methods for serializing and deserializing user data
  */

@Log4j2
public class JsonConverter {
    private String message;

    public JsonConverter(String message) {
        this.message = message;
    }
    public JsonConverter() {

    }

    public void writeUserToPath(User user, String filePath) {
        log.info("Serializing user data for {} to file: {}", user.getUsername(), filePath);
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try(FileWriter writer = new FileWriter(filePath)) {
            gson.toJson(user, writer);
            writer.flush();
            log.info("Serialized user data for {} to file: {}", user.getUsername(), filePath);
        } catch(IOException ex) {
            log.error("Error - failed to serialize data for {} to JSON at {}: ", user.getUsername(), filePath, ex);
        }
    }

    public String serializeMessage() {
        log.info("Serializing message");
        try {
            Gson gson = new Gson();
            return gson.toJson(this) + "\n<<END>>";
        } catch (Exception e) {
            throw new IllegalStateException("Error - failed to serialize JsonResponse to JSON", e);
        }
    }

    public static String deserializeMessage(String json) {
        log.info("Deserializing message");
        if (json == null || json.trim().isEmpty()) {
            throw new IllegalArgumentException("Input JSON is null or empty");
        }
        try {
            Gson gson = new Gson();
            JsonConverter jsonConverter = gson.fromJson(json, JsonConverter.class);
            log.info("Deserialized message: {}", json);
            return jsonConverter.toString();
        } catch (JsonSyntaxException e) {
            throw new IllegalArgumentException("Error deserializing JSON. Please check syntax", e);
        }
    }

    public void saveUserData(User newUser){
        writeUserToPath(newUser, "C:\\Users\\Jakub Bone\\Desktop\\Z2J\\projects\\Client-Server\\" + newUser.getUsername() + ".json");
    }

    @Override
    public String toString() {
        return message;
    }
}

====================
FILE: ResponseMessage.java

package shared;

import lombok.extern.log4j.Log4j2;

@Log4j2
public enum ResponseMessage {

    // General responses
    OPERATION_SUCCEEDED("Operation succeeded"),
    OPERATION_FAILED("Operation failed"),
    FAILED_TO_FIND_USER("Failed to find user"),

    // Register responses
    REGISTRATION_SUCCESSFUL("Registration successful"),
    REGISTRATION_FAILED_USER_EXISTS("Registration failed: User already exists"),

    // Login responses
    USER_LOGIN_SUCCEEDED("User login successful"),
    ADMIN_LOGIN_SUCCEEDED("Admin login successful"),
    LOGIN_FAILED_INCORRECT_PASSWORD("Login failed: Incorrect password"),

    // Logout response
    LOGOUT_SUCCEEDED("Logout succeeded"),

    // Authorization responses
    AUTHORIZATION_SUCCEEDED("Authorization succeeded"),
    AUTHORIZATION_FAILED("Authorization failed"),

    // Account switch responses
    SWITCH_SUCCEEDED("Switch succeeded"),
    SWITCH_FAILED("Switch failed"),

    // Role change responses
    ROLE_CHANGE_SUCCEEDED("Role change succeeded"),
    ROLE_CHANGE_FAILED("Role change failed"),

    // Mail responses
    SENDING_SUCCEEDED("Sending succeeded"),
    SENDING_FAILED_BOX_FULL("Sending failed: Recipient's mailbox is full"),
    SENDING_FAILED_TO_LONG_MESSAGE("Sending failed: Message too long (maximum 255 characters)"),
    SENDING_FAILED_RECIPIENT_NOT_FOUND("Sending failed: Recipient not found"),
    MAIL_DELETION_SUCCEEDED("Mails deletion succeeded"),
    MAILBOX_EMPTY("Mailbox is empty"),

    // Unknown Message
    UNKNOWN_REQUEST("Unknown request"),
    UNKNOWN_RESPONSE("Unknown response");

    private final String RESPONSE;

    ResponseMessage(String response){
        this.RESPONSE = response;
    }

    public String getResponse() {
        return RESPONSE;
    }

    public static ResponseMessage fromString(String text) {
        log.info("Converting text to OperationResponses: {}", text);
        for (ResponseMessage message : ResponseMessage.values()) {
            if (message.getResponse().equals(text)) {
                log.info("Match found for text: {}", text);
                return message;
            }
        }
        log.warn("No match found for text: {}", text);
        return UNKNOWN_RESPONSE;
    }
}


====================
FILE: Screen.java

package shared;

public class Screen {

    public static void printLoginMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              Welcome in MailBox!            |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Register                                    |\n" +
                "| Login                                       |\n" +
                "| Uptime                                      |\n" +
                "| Info                                        |\n" +
                "| Help                                        |\n" +
                "| Exit                                        |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printAdminMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Update                                      |\n" +
                "| Switch                                      |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printUserMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }
}

====================
FILE: UserInteraction.java

package shared;

import java.io.BufferedReader;
import java.io.IOException;

import user.User.Role;

/*
  * The UserInteraction class is responsible for interaction with users through the console
  * The methods used to obtain user input for various purposes, such as usernames, passwords, and mailbox operations
  */
public class UserInteraction {
    private BufferedReader reader;
    public UserInteraction(BufferedReader reader) {
        this.reader = reader;
    }

    public String getUsername() throws IOException {
        System.out.print("Please type your username: ");
        return reader.readLine();
    }

    public String getPassword() throws IOException {
        System.out.print("Please type your password: ");
        return reader.readLine();
    }

    public String getNewPassword() throws IOException{
        System.out.print("Please type a new password: ");
        return reader.readLine();
    }

    public String getRecipient() throws IOException {
        System.out.print("Please type a recipient's username: ");
        return reader.readLine();
    }

    public String getMessage() throws IOException {
        System.out.println("Please type your message (max 255 characters): ");
        return reader.readLine();
    }

     public String getUserToSwitch() throws IOException {
         System.out.print("Please type a username to switch: ");
         return reader.readLine();
     }

    public String chooseBoxOperation() throws IOException {
        while (true) {
            System.out.println("Mailbox operation: READ / EMPTY: ");
            System.out.print("Select: ");
            String operation = reader.readLine().toUpperCase();
            switch (operation) {
                case "READ":
                case "EMPTY":
                    return operation;
                default:
                    System.out.println("Invalid operation. Please try again!");;
            }
        }
    }
    public String chooseMailBox() throws IOException {
        while (true) {
                System.out.println("Mailbox: OPENED / UNREAD / SENT");
                System.out.print("Select: ");
                String mailbox = reader.readLine().toUpperCase();
                switch (mailbox) {
                    case "OPENED":
                    case "UNREAD":
                    case "SENT":
                        return mailbox;
                    default:
                        System.out.println("Invalid mailbox type. Please try again!");
                }
        }
    }

    public String chooseUpdateOperation() throws IOException {
        while (true) {
            System.out.println("Update operations: PASSWORD / DELETE / ROLE");;
            System.out.print("Select: ");;
            String input = reader.readLine();
            switch (input.toUpperCase()) {
                case "PASSWORD":
                    return "PASSWORD";
                case "DELETE":
                    return "DELETE";
                case "ROLE":
                    return "ROLE";
                default:
                    System.out.println("Invalid operation type. Please try again!");
            }
        }
    }

    public String chooseUserToUpdate() throws IOException {
        System.out.print("Please type an username to update: ");
        return reader.readLine();
    }

    public Role chooseRole() throws IOException {
        System.out.print("Please type the new role (ADMIN / USER): ");
        String newRole = reader.readLine();
        if(newRole.equals("ADMIN")){
            return Role.ADMIN;
        } else {
            return Role.USER;
        }
    }
}

====================
FILE: Admin.java

package user;

import lombok.extern.log4j.Log4j2;
import shared.JsonConverter;

@Log4j2
public class Admin extends User {

    JsonConverter jsonConverter = new JsonConverter();

    public Admin() {
        super("admin", "java10", Role.ADMIN);
        log.info("Admin instance created");
    }

    public void changePassword(User user, String newPassword){
        log.info("Changing password for user: {}", user.getUsername());
        user.setPassword(newPassword);
        jsonConverter.saveUserData(user);
        log.info("Password change succeeded for user: {}", user.getUsername());
    }

    public void deleteUser(User user){
        log.info("Deleting user: {}", user.getUsername());
        UserManager.usersList.remove(user);
        log.info("User deletion succeeded: {}", user.getUsername());
    }

    public void changeUserRole(User user, User.Role role){
        log.info("Changing role for user: {}", user.getUsername());
        user.setRole(User.Role.ADMIN);
        log.info("Role change succeeded for user: {} to {}", user.getUsername(), role);
    }

    public void switchUser(User user) {
        log.info("Switching to user: {}", user.getUsername());
        UserManager.currentLoggedInUser = user;
        UserManager.ifAdminSwitched = true;
        log.info("Switched to user: {}", user.getUsername());
        }
}



====================
FILE: User.java

package user;

import mail.MailBox;
import org.mindrot.jbcrypt.BCrypt;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

@Getter
@Setter
@Log4j2
public class User {

    public enum Role {
        ADMIN,
        USER;
    }
    protected String username;
    protected String password;
    protected String hashedPassword;
    protected Role role;
    protected MailBox mailBox;

    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.mailBox = new MailBox();
        this.hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        log.info("User instance created: {}", username);
    }

    /*
    BCrypt.checkpw() check whether hashed 'typedPassword' matches with 'hashedPassword'
    Bcrypt uses salt and protects against attacks, ensuring unique hashes even for identical passwords is
    */
    public boolean checkPassword(String typedPassword) {
        log.info("Checking password for user: {}", username);
        return BCrypt.checkpw(typedPassword, hashedPassword);
    }

    public void hashPassword(){
        hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        log.info("Password hashed for user: {}", username);
    }

    public void setPassword(String newPassword) {
        log.info("Setting new password for user: {}", username);
        this.password = newPassword;
        hashPassword();
        log.info("New password set for user: {}", username);
    }

    public String toString() {
        return username;
    }
}

====================
FILE: UserManager.java

package user;

import java.util.ArrayList;
import java.util.List;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import shared.JsonConverter;
import shared.ResponseMessage;

/*
 * The UserManager class manages user-related operations such as registration, login, and logout.
 * It maintains a list of users and tracks the currently logged-in user.
 */

@Log4j2
@Getter
@Setter
public class UserManager {
    public static List<User> usersList;
    public static User currentLoggedInUser;
    JsonConverter jsonConverter;
    public static boolean ifAdminSwitched;
    public Admin admin;

    public UserManager() {
        this.admin = new Admin();
        jsonConverter = new JsonConverter();
        jsonConverter.saveUserData(admin);
        usersList = new ArrayList<>();
        usersList.add(admin);
        log.info("UserManager instance created");
    }

     /*
      * Registers a new user with the specified username and password
      * If the username already exists, it's failure
      * Otherwise, successful registration
      */


    public String registerAndGetResponse(String username, String password) {
        log.info("Registration attempted for user: {}", username);

        if (isUserExistsInSystem(username)) {
            log.info("Registration attempt failed - user already exists: {}", username);
            return ResponseMessage.REGISTRATION_FAILED_USER_EXISTS.getResponse();
        }

        register(username, password);
        log.info("Registration successful for new user: {}", username);
        return ResponseMessage.REGISTRATION_SUCCESSFUL.getResponse();
    }

    public void register(String username, String password) throws IllegalArgumentException {
        User newUser = new User(username, password, User.Role.USER);
        jsonConverter.saveUserData(newUser);
        usersList.add(newUser);
        currentLoggedInUser = newUser;
        log.info("User registered: {}", username);
    }


    public String loginAndGetResponse(String username, String password) {
        log.info("Login attempted for user: {}", username);
        User user = getUserByUsername(username);

        if (user == null) {
            log.info("Login attempt failed - user does not exist: {}", username);
            return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
        }

        if (!ifPasswordCorrect(password, user)) {
            log.info("Incorrect password attempt for user: {}", user.getUsername());
            return ResponseMessage.LOGIN_FAILED_INCORRECT_PASSWORD.getResponse();
        }

        log.info("User password correct: {}", user.getUsername());
        login(user);
        log.info("User login succeeded: {}", user.getUsername());

        if (ifCurrentUserAdmin()) {
            return ResponseMessage.ADMIN_LOGIN_SUCCEEDED.getResponse();
        } else {
            return ResponseMessage.USER_LOGIN_SUCCEEDED.getResponse();
        }
    }

    public void login(User existingUser) {
        currentLoggedInUser = existingUser;
        log.info("User logged in: {}", existingUser.getUsername());
    }

    public boolean isUserExistsInSystem(String username) {
        return getUserByUsername(username) != null;
    }

    public boolean ifPasswordCorrect(String password, User existingUser) {
        return existingUser.checkPassword(password);
    }

    public String getLogoutResponse() {
        log.info("User logout requested");
        logoutCurrentUser();
        return ResponseMessage.LOGOUT_SUCCEEDED.getResponse();
    }

    public void logoutCurrentUser() {
        log.info("User logout succeeded: {}", currentLoggedInUser.getUsername());
        ifAdminSwitched = false;
        currentLoggedInUser = null;
    }

    // Finds a user by the username
    public User getUserByUsername(String username) {
        for (User user : usersList) {
            if (username.equals(user.getUsername())) {
                log.info("User found on the list: {}", username);
                return user;
            }
        }
        log.warn("User not found on the list: {}", username);
        return null;
    }

    public boolean ifCurrentUserAdmin(){
        log.info("Admin role checking for user: {}", currentLoggedInUser.getUsername());
        return currentLoggedInUser != null && currentLoggedInUser.getRole().equals(User.Role.ADMIN);
    }

}

====================
FILE: ClientCommunicationTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;

import org.junit.jupiter.api.*;
import shared.ResponseMessage;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ClientCommunicationTest {
    static ClientConnection clientConnection;
    Socket mockSocket;
    PrintWriter mockOutToServer;
    BufferedReader mockInFromServer;

    @BeforeEach
    void setUp() {
        mockSocket = mock(Socket.class);
        mockOutToServer = mock(PrintWriter.class);
        mockInFromServer = mock(BufferedReader.class);
        clientConnection = new ClientConnection();
        clientConnection.setClientSocket(mockSocket);
        clientConnection.setOutToServer(mockOutToServer);
        clientConnection.setInFromServer(mockInFromServer);
    }

    @AfterAll
    static void closeDown() {
        clientConnection.disconnect();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectToServer()  {
        Assertions.assertTrue(clientConnection.isConnected());
    }

    @Test
    @DisplayName("Should test sending request")
    void testSendRequest() {
        String request = "exampleRequest";

        clientConnection.sendRequest(request);

        // Verify that the request was sent to the server
        verify(mockOutToServer).println(request);
    }

    @Test
    @DisplayName("Should test checking response status")
    void testReadResponse() throws IOException {
        String jsonResponse1 = "{\"message\":\"response1\"}";
        String jsonResponse2 = "{\"message\":\"response2\"}";

        // Mock server responses
        when(mockInFromServer.readLine())
                .thenReturn(jsonResponse1, jsonResponse2, "<<END>>");

        clientConnection.readResponse();

        // Verify that the responses were read from the server
        verify(mockInFromServer, times(3)).readLine();
    }

    @Test
    @DisplayName("Should check response status")
    void testCheckResponseStatus() {
        // Test admin login succeeded
        String response = ResponseMessage.ADMIN_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());
        assertTrue(clientConnection.isAuthorized());

        // Test user login succeeded
        response = ResponseMessage.USER_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test registration succeeded
        response = ResponseMessage.REGISTRATION_SUCCESSFUL.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test logout succeeded
        response = ResponseMessage.LOGOUT_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isLoggedIn());
        assertFalse(clientConnection.isAuthorized());
        assertFalse(clientConnection.isAdminSwitchedAndAuthorized());

        // Test authorization succeeded
        response = ResponseMessage.AUTHORIZATION_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isAuthorized());

        // Test operation failed response
        response = ResponseMessage.SWITCH_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isAuthorized());
        assertTrue(clientConnection.isAdminSwitchedAndAuthorized());
    }
}

====================
FILE: ClientTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;

import org.junit.jupiter.api.*;
import org.mockito.MockedStatic;
import request.Request;
import request.RequestService;
import shared.Screen;
import shared.UserInteraction;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static shared.Screen.printAdminMailBoxMenu;

class ClientTest {
    Client client;
    static ClientConnection mockConnection;
    BufferedReader mockUserInput;
    UserInteraction mockUserInteraction;
    RequestService mockRequestService;
    Request mockRequestType;

    @BeforeEach
    void setUp() {
        client = new Client();
        mockConnection = mock(ClientConnection.class);
        mockUserInput = mock(BufferedReader.class);
        client.setConnection(mockConnection);
        client.setUserInput(mockUserInput);
        mockUserInteraction = mock(UserInteraction.class);
        mockRequestService = mock(RequestService.class);
        mockRequestType = mock(Request.class);
    }

    @AfterAll
    static void closeDown() {
        mockConnection.disconnect();
    }

    @Test
    @DisplayName("Should test disconnect when user inputs 'EXIT'")
    void testHandleServerCommunication_EXIT() throws IOException {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockUserInput.readLine()).thenReturn("EXIT");

        client.handleServerCommunication();

        // Verify that the client disconnects from the server when "EXIT" is entered
        assertTrue(mockConnection.isConnected());
        assertTrue(mockConnection.isLoggedIn());
        verify(mockConnection, times(1)).disconnect();
    }

    @Test
    @DisplayName("Should test communication handling when admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockConnection.isAuthorized()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> printAdminMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when non-admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Not_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> Screen.printUserMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT LOGGED IN")
    void testHandleServerCommunication_NotLoggedIn() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(false);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the login menu is displayed when the user is not logged in
        mockScreen.verify(() -> Screen.printLoginMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT CONNECTED")
    void testHandleServerCommunication_NotConnected() throws IOException {
        when(!mockConnection.isConnected()).thenReturn(false);

        client.handleServerCommunication();

        // Verify that no actions are taken when the client is not connected
        verify(mockConnection, never()).isLoggedIn();
        verify(mockUserInput, never()).readLine();
    }

    @Test
    @DisplayName("Should test request handling")
    void testHandleRequest() throws IOException {
        when(mockUserInput.readLine()).thenReturn("LOGIN");
        when(mockRequestService.getRequest("LOGIN")).thenReturn(mockRequestType);

        client.handleRequest("LOGIN");

        // Verify that the request is handled properly
        verify(mockConnection).sendRequest(anyString());
        verify(mockConnection).readResponse();
    }
}

====================
FILE: AccountUpdateHandlerTest.java

package handler;

import handler.user.AccountUpdateHandler;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.ResponseMessage;
import user.Admin;
import user.User;
import user.UserManager;

import static org.junit.jupiter.api.Assertions.*;

class AccountUpdateHandlerTest {
    AccountUpdateHandler updateHandler;
    UserManager userManager;

    @BeforeEach
    void setUp() {
        updateHandler = new AccountUpdateHandler();
        userManager = new UserManager();
    }

    @Test
    @DisplayName("Should test getting update response for password change")
    void testGetPasswordChangeResponse() {
        Admin admin = new Admin();

        // Admin login
        userManager.login(admin);
        // Password changing
        String response = updateHandler.getChangePasswordResponse(admin.getUsername(), "newPasswod", userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.OPERATION_SUCCEEDED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test getting update status for user account deletion")
    void testGetUserDeleteResponse() {
        String userName = "exampleUsername";
        String password = "examplePassword";
        Admin admin = new Admin();

        // User register
        userManager.register(userName, password);
        // Admin login
        userManager.login(admin);
        // User account deletion
        String response = updateHandler.getUserDeleteResponse(userName, userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.OPERATION_SUCCEEDED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test getting update response for user role change")
    void testGetChangeRoleResponse() {
        Admin admin = new Admin();

        // Admin login
        userManager.login(admin);
        // Role changing
        String response = updateHandler.getChangeRoleResponse(admin.getUsername(), User.Role.USER, userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.ROLE_CHANGE_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: MailBoxTest.java

package mail;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.User;

import static org.junit.jupiter.api.Assertions.*;

class MailBoxTest {
    MailBox mailBox;
    User sender;
    User recipient;
    Mail mail;

    @BeforeEach
    void setUp() {
        mailBox = new MailBox();
        sender = new User("exampleSender", "examplePassword", User.Role.USER);
        recipient = new User("exampleRecipient", "examplePassword", User.Role.USER);
        mail = new Mail(sender, recipient, "Example message");
    }

    @Test
    @DisplayName("Should test if unread box is not full when it contains less than 5 messages")
    void testIfUnreadBoxNotFull() {
        recipient.getMailBox().getUnreadBox().add(mail);
        // Test if the unread box is not full when it has ony 1 message
        assertFalse(recipient.getMailBox().ifUnreadBoxFull());
    }

    @Test
    @DisplayName("Should test if unread box is full when it contains 5 messages")
    void testIfUnreadBoxFull() {
        for (int i = 0; i < 5; i++) {
            recipient.getMailBox().getUnreadBox().add(mail);
        }
        // Test if the unread box is full when it has exactly 5 messages
        assertTrue(recipient.getMailBox().ifUnreadBoxFull());
    }

    @Test
    @DisplayName("Should test if unread box is full when it contains more than 5 messages")
    void testIfUnreadBoxOverFull() {
        for (int i = 0; i < 8; i++) {
            recipient.getMailBox().getUnreadBox().add(mail);
        }
        // Test if the unread box is full when it has more than 5 messages
        assertTrue(recipient.getMailBox().ifUnreadBoxFull());
    }
}

====================
FILE: MailServiceTest.java

package mail;

import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.User;
import user.UserManager;

import static org.junit.jupiter.api.Assertions.*;

class MailServiceTest {
    User sender;
    User recipient;
    Mail mail;
    MailService mailService;
    MailBox mailBox;

    @BeforeEach
    void setUp() {
        sender = new User("senderName", "examplePassword", User.Role.USER);
        recipient = new User("recipientName", "examplePassword", User.Role.USER);
        mail = new Mail(sender, recipient, "Example message");
        mailService = new MailService();
        mailBox = new MailBox();
        UserManager.currentLoggedInUser = sender;
    }

    @Test
    @DisplayName("Should test mail sending")
    void testSendMail() {
        mailService.sendMail(mail);

        assertTrue(sender.getMailBox().getSentBox().contains(mail));
        assertTrue(recipient.getMailBox().getUnreadBox().contains(mail));
    }

    @Test
    @DisplayName("Should test specific mail list returning")
    void testGetMailsToRead() {
        String requestedMailBox = "UNREAD";

        // Test returning unread mails
        List<Mail> mailList = mailService.getMailsToRead(requestedMailBox);

        assertTrue(mailBox.getUnreadBox().equals(mailList));
    }

    @Test
    @DisplayName("Should test emptying mailbox")
    void testEmptyMailbox() {
        String requestedMailBox = "OPEN";

        // Test emptying the opened mailbox
        mailService.deleteEmails(requestedMailBox);

        assertTrue(mailBox.getOpenedBox().isEmpty());
    }

    @Test
    @DisplayName("Should test marking mails as read")
    void testMarkMailsAsRead() {
        String requestedMailBox = "UNREAD";
        List<Mail> mailList = List.of(mail);
        mailBox.setUnreadBox(mailList);

        assertFalse(mailBox.getUnreadBox().isEmpty());
        // Test marking mails as read
        mailService.markMailsAsRead(requestedMailBox);
        assertTrue(mailBox.getSentBox().isEmpty());
    }
}

====================
FILE: RequestServiceTest.java

package request;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.UserInteraction;
import user.User;
import user.UserManager;
import client.ClientConnection;

import static org.junit.jupiter.api.Assertions.*;

class RequestServiceTest {
    RequestService requestService;
    RequestFactory factory;
    UserInteraction userInteraction;
    BufferedReader reader;
    User exampleUser;
    UserManager userManager;
    ClientConnection clientConnection;

    @BeforeEach
    void setUp() {
        exampleUser = new User("exampleName", "examplePassword", User.Role.USER);
        UserManager.currentLoggedInUser = exampleUser;
        clientConnection = new ClientConnection();
        requestService = new RequestService(clientConnection);
        factory = new RequestFactory();
        reader = new BufferedReader(new InputStreamReader(System.in));
        userManager = new UserManager();
        userInteraction = new UserInteraction(reader);
    }

    @Test
    @DisplayName("Should test request creating for logged user")
    void testGetRequest_Client_LoggedIn() throws IOException {
        String request = "REGISTER";
        Request expectedType = factory.createAuthRequest(request,
                exampleUser.getUsername(), "examplePassword");
        ClientConnection.loggedIn = false;

        // Test AuthRequest creating
        Request requestType = requestService.getRequest(request);

        assertNotNull(requestType);
        assertEquals(expectedType.getClass(), requestType.getClass());
    }

    @Test
    @DisplayName("Should test request creating for not logged user")
    void testCreateRequest_Client_LoggedOut() throws IOException {
        String request = "WRITE";
        Request expectedType = factory.createWriteRequest(request,
                "exampleUsername", "exampleMessage");
        ClientConnection.loggedIn = true;

        // Test WriteRequest creating
        Request requestType = requestService.getRequest(request);

        assertNotNull(requestType);
        assertEquals(expectedType.getClass(), requestType.getClass());
    }

    @Test
    @DisplayName("Should test account update request creating for non-admin user")
    void testGetAccountUpdateRequest_Not_Authorized() throws IOException {
        clientConnection.setAuthorized(false);

        // // Test AccountUpdateRequest getting
        Request requestType = requestService.getAccountUpdateRequest();

        assertNull(requestType);
    }
}

====================
FILE: ServerConnectionTest.java

package server;

import java.io.BufferedReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ServerConnectionTest {
    ServerConnection handler;
    ServerSocket mockServerSocket;
    Socket mockClientSocket;
    BufferedReader mockInFromClient;
    PrintWriter mockOutToClient;

    @BeforeEach
    void setUp() {
        handler = new ServerConnection(5000);
        mockServerSocket = mock(ServerSocket.class);
        mockClientSocket = mock(Socket.class);
        mockInFromClient = mock(BufferedReader.class);
        mockOutToClient = mock(PrintWriter.class);
        handler.setClientSocket(mockClientSocket);
        handler.setServerSocket(mockServerSocket);
        handler.setOutToClient(mockOutToClient);
        handler.setInFromClient(mockInFromClient);
    }

    @AfterEach
    void closeDown()  {
        handler.closeConnections();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectWithClient() {
        when(mockClientSocket.isConnected()).thenReturn(true);
        handler.startServer();

        // Verify that the client is connected
        assertTrue(mockClientSocket.isConnected());
    }
}

====================
FILE: JsonConverterTest.java

package shared;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class JsonConverterTest {
    @Test
    @DisplayName("Should test message serializing to JSon")
    void testSerializeMessage() {
        String message = "exampleMessage";
        JsonConverter converter = new JsonConverter(message);
        String expectedFormat = "{\"message\":\"exampleMessage\"}\n<<END>>";

        // Test JSON serialization
        String serializedMessage = converter.serializeMessage();

        assertNotNull(serializedMessage);
        assertEquals(serializedMessage, expectedFormat);
    }

    @Test
    @DisplayName("Should test message deserializing from JSon")
    void testDeserializeMessage() {
        String message = "exampleMessage";
        JsonConverter converter = new JsonConverter(message);

        String serializedMessage = converter.serializeMessage();

        // Removing "\n<<END>>" from the end of JSon message
        String jsonWithoutEndTag = serializedMessage.replace("\n<<END>>", "");

        // Test JSON deserialization
        String deserializedMessage = converter.deserializeMessage(jsonWithoutEndTag);

        assertNotNull(deserializedMessage);
        assertEquals(message, deserializedMessage);
    }
}

====================
FILE: AdminTest.java

package user;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class AdminTest {
    UserManager userManager;

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
    }

    @Test
    @DisplayName("Should test changing user password")
    void testChangePassword() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.register(username, password);

        // Find the user and change the password
        User user = userManager.getUserByUsername(username);
        userManager.getAdmin().changePassword(user, "newPassword");

        assertNotEquals(user.getPassword(), password);
        assertEquals(user.getPassword(), "newPassword");
    }

    @Test
    @DisplayName("should test deleting user")
    void testDeleteUser() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.register(username, password);

        // Find the user and delete
        User user = userManager.getUserByUsername(username);
        userManager.getAdmin().deleteUser(user);

        assertNull(userManager.getUserByUsername(username));
    }

    @Test
    @DisplayName("should test user role changing")
    void testChangeUserRole() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.register(username, password);

        // Find the user change the role
        User user = userManager.getUserByUsername(username);
        userManager.getAdmin().changeUserRole(user, User.Role.ADMIN);

        assertEquals(Admin.Role, User.Role);
    }

    @Test
    @DisplayName("should test user switching")
    void testSwitchUser() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.register(username, password);

        // Find the user change the role
        User user = userManager.getUserByUsername(username);
        userManager.getAdmin().switchUser(user);

        assertTrue(UserManager.currentLoggedInUser.equals(user));
        assertTrue(UserManager.ifAdminSwitched);
    }
}

====================
FILE: UserMangerTest.java

package user;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class UserMangerTest {
    UserManager userManager;

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
    }
    @Test
    @DisplayName("Should test user registration for the first time")
    void testRegister() {
        String userName = "exampleUsername";
        String password = "examplePassword";
        User newUser = new User(userName, password, User.Role.USER);

        // Test user registration with a new username
        userManager.register(userName, password);
        assertEquals(UserManager.currentLoggedInUser.getUsername(), userName);
        assertEquals(UserManager.currentLoggedInUser.getPassword(), password);
        assertEquals(UserManager.currentLoggedInUser.role, User.Role.USER);
    }

    @Test
    @DisplayName("Should test user registration with existing username")
    void testRegisterExistingUser() {
        String userName = "exampleUsername";
        String password = "examplePassword";

        // Register the user for the first time
        userManager.register(userName, password);

        // Attempt to register the same user again
        userManager.register(userName, password);
        String registrationStatus = userManager.registerAndGetResponse(userName, password);

        assertEquals("Registration failed: User already exists", registrationStatus);
    }

    @Test
    @DisplayName("Should test user login with correct credentials")
    void testLoginCorrect() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User newUser = new User(username, password, User.Role.USER);

        // Register the user first
        userManager.register(username, password);

        // Attempt to log in with correct credentials
        userManager.login(newUser);


        assertNotNull(UserManager.currentLoggedInUser);
        assertEquals(username, UserManager.currentLoggedInUser.getUsername());
        assertEquals(password, UserManager.currentLoggedInUser.getPassword());
    }

    @Test
    @DisplayName("Should test user login with incorrect credentials")
    void testLoginIncorrect() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User anotherUser = new User(username,"wrongPassword" , User.Role.USER);

        // Register the user first
        userManager.register(username, password);

        // Attempt to log in with incorrect password
        userManager.login(anotherUser);
        String loginStatus = userManager.loginAndGetResponse(username, "wrongPassword");
        assertEquals("Login failed: Incorrect password", loginStatus);
    }

    @Test
    @DisplayName("Should test user logout")
    void testLogout() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User user = new User(username,password , User.Role.USER);

        // Register and login the user first
        userManager.register(username, password);
        userManager.login(user);

        // Logout the current user
        userManager.logoutCurrentUser();

        assertNull(UserManager.currentLoggedInUser);
    }

    @Test
    @DisplayName("Should test finding user by username")
    void testFindUserByUsername() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register the user first
        userManager.register(username, password);

        // Find the user by username
        User foundUser = userManager.getUserByUsername(username);

        assertNotNull(foundUser);
        assertEquals(username, foundUser.getUsername());
    }

    @Test
    @DisplayName("Should test if current user is admin")
    void testIfCurrentUserAdmin() {
        User admin = new Admin();

        // Log in as the admin user
        userManager.login(admin);

        assertTrue(userManager.ifCurrentUserAdmin());
    }
}

====================
FILE: UserTest.java

package user;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class UserTest {
    @Test
    @DisplayName("Should test password matching functionality with correct password")
    void testCheckPasswordCorrect() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "examplePassword";

        boolean isMatching =  user.checkPassword(typedPassword);

        assertTrue(isMatching);
    }

    @Test
    @DisplayName("Should test password matching functionality with incorrect password")
    void testCheckPasswordIncorrect() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "incorrectPassword";

        boolean isMatching =  user.checkPassword(typedPassword);

        assertFalse(isMatching);
    }

    @Test
    @DisplayName("Should test password hashing functionality")
    void testHashPassword() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "examplePassword";

        user.hashPassword();

        assertNotNull(user.getHashedPassword());
        assertTrue(user.checkPassword(typedPassword));
    }
}

