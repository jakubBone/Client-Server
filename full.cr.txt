====================
FILE: Client.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import com.google.gson.Gson;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import request.*;
import shared.Screen;

/**
 * This class represents a client application for server communication.
 * It handles user login, sending requests, and interacting with a mailbox.
 */

@Log4j2
@Getter
@Setter
public class Client {
    private ClientConnection connection;
    private BufferedReader userInput;
    private static Gson gson;

    public static void main(String[] args) {
        Client client = new Client();
        client.handleServerCommunication();
    }

    public Client() {
        connection = new ClientConnection();
        gson = new Gson();
        userInput = new BufferedReader(new InputStreamReader(System.in));
        log.info("Client instance created");
    }

    public void handleServerCommunication() {
        try {
            log.info("Starting server communication");
            while(connection.isConnected()){
                printClientUI();
                String request = userInput.readLine();
                if (request == null || request.equalsIgnoreCase("EXIT")) {
                    connection.disconnect();
                    log.info("User exited the application");
                    return;
                }
                    handleRequest(request);
            }
        } catch (IOException ex) {
            log.error("Error in handling server communication: {}", ex.getMessage());
        }
    }


    /**
     * Processes a user request by sending it to the server.
     * Converts the user request into the appropriate format and sends it to the server.
     * @param request The user input request
     */
    public void handleRequest(String request) throws IOException {
        log.info("Handling user request: {}", request);
        try{
            RequestService requestService = new RequestService(connection);
            Request requestType = requestService.getRequest(request);

            if (requestType != null) {
                String jsonRequest = gson.toJson(requestType);
                connection.sendRequest(jsonRequest);
                log.info("User attempted to {}", request);
                connection.readResponse();
            } else {
                log.warn("Incorrect input from user: {}", request);
                System.out.println("Incorrect input. Please, try again");
            }
        } catch (IOException ex){
            log.error("Error handling request: {}", ex.getMessage());
        }
    }

    public void printClientUI(){
        if(!connection.isLoggedIn()) {
            Screen.printLoginMenu();
        } else {
            if(connection.isAuthorized()){
                Screen.printAdminMailBoxMenu();
            } else{
                Screen.printUserMailBoxMenu();
            }
        }
    }
}

====================
FILE: ClientConnection.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import shared.JsonConverter;

/**
 * The ClientConnection class manages the connection between the client and server.
 * It establishes, maintains, and handles communication through sockets.
 * Additionally, it manages login status and authorization checks.
 */

@Log4j2
@Getter
@Setter
public class ClientConnection {
    private final int PORT_NUMBER = 5000;
    private Socket clientSocket;
    private PrintWriter outToServer;
    private BufferedReader inFromServer;
    public static boolean loggedIn = false;
    private boolean isAuthorized = false;
    private boolean  isAdminSwitchedAndAuthorized = false;
    public static int connectionAttempts = 0;
    private boolean connected = false;


    public ClientConnection() {
        connectToServer();
        log.info("ClientConnection instance created");
    }

    /**
     * Attempts to connect to the server.
     * If the initial connection fails, it tries to reconnect.
     */
    public void connectToServer() {
        try {
            clientSocket = new Socket("localhost", PORT_NUMBER);
            outToServer = new PrintWriter(clientSocket.getOutputStream(), true);
            inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            connected = true;
            log.info("Connection with Server established on port {}", PORT_NUMBER);
        } catch (IOException ex) {
            log.error("Failed to establish connection with the server at port {}. Error: {}", PORT_NUMBER, ex.getMessage());
            retryConnection();
        }
    }

    /**
     * Retries connection to the server up to a maximum number of attempts.
     */
    public void retryConnection() {
        if (connectionAttempts >= 2) {
            log.error("Max reconnection attempts reached. Giving up");
            disconnect();
            return;
        }
        try {
            Thread.sleep(2000);
            log.info("Attempting to reconnect to the server...");
            Thread.sleep(5000);
            connectionAttempts++;
            connectToServer();
        } catch (InterruptedException ie) {
            Thread.currentThread().interrupt();
            log.warn("Reconnection attempt interrupted", ie);
        }
    }

    public void sendRequest(String request) {
        outToServer.println(request);
        log.info("Sent request to server: {}", request);
    }

    public void readResponse() throws IOException {
        try{
            String jsonResponse;
            log.info("Reading response from server");
            while (!(jsonResponse = inFromServer.readLine()).equals("<<END>>")) {
                String response = JsonConverter.deserializeMessage(jsonResponse);
                checkResponseStatus(response);
                System.out.println(JsonConverter.deserializeMessage(jsonResponse));
            }
        } catch (IOException ex){
            log.error("Error reading response: {}", ex.getMessage());
        }
    }

    /**
     * Checks the status of the response from the server.
     * Updates login and authorization status based on the response.
     * @param response The response from the server
     */
    public void checkResponseStatus(String response) {
        ResponseMessage operationMessage = ResponseMessage.fromString(response);
        System.out.println(operationMessage);
        switch (operationMessage) {
            case ADMIN_LOGIN_SUCCEEDED:
                loggedIn = true;
                isAuthorized = true;
                log.info("Admin login succeeded");
                break;
            case USER_LOGIN_SUCCEEDED:
                loggedIn = true;
                log.info("User login succeeded");
                break;
            case REGISTRATION_SUCCESSFUL:
                loggedIn = true;
                log.info("User registered succeeded");
                break;
            case LOGOUT_SUCCEEDED:
                loggedIn = false;
                isAuthorized = false;
                isAdminSwitchedAndAuthorized = false;
                log.info("User logout succeeded");
                break;
            case AUTHORIZATION_SUCCEEDED:
                isAuthorized = true;
                log.info("User authorization succeeded");
                break;
            case SWITCH_SUCCEEDED:
                isAuthorized = false;
                isAdminSwitchedAndAuthorized = true;
                log.info("Switch succeeded");
                break;
            default:
                log.info("No response required to action");
        }
    }

    public void disconnect() {
        try {
            if (outToServer != null) {
                outToServer.close();
            }
            if (inFromServer != null) {
                inFromServer.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            log.info("Client disconnected");
        } catch (IOException ex) {
            log.error("Error during disconnection: {}", ex.getMessage());
        }
    }

    public boolean isLoggedIn() {
        return loggedIn;
    }

    public boolean isAuthorized() {
        return isAuthorized;
    }
    public boolean isConnected(){
        return connected;
    }
}

====================
FILE: DatabaseConnection.java

package database;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class DatabaseConnection {
    private final String USER = "user_manager";
    private final String PASSWORD = "user123";
    private final String DATABASE = "user_db";
    private final int PORT_NUMBER = 5432;
    private final String URL = String.format("jdbc:postgresql://localhost:%d/%s", PORT_NUMBER, DATABASE);
    private static DatabaseConnection instance;
    private static Connection connection;

    public DatabaseConnection() {
        startConnection();
    }

    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }

    public void startConnection() {
        try {
            log.info("Attempting to connect with data base");
            connection = DriverManager.getConnection(URL, USER, PASSWORD);
            if(connection != null){
                log.info("Connection with {} database established on port {}", USER, PORT_NUMBER);
            } else {
                log.info("Failed to connect with {} database established on port {}", USER, PORT_NUMBER);
            }
        } catch (SQLException ex) {
            log.error("Error during database connection: {}", ex.getMessage());
            throw new RuntimeException("Error establishing database connection", ex);
        }
    }

    public Connection getConnection(){
        return connection;
    }

    public void disconnect() {
        try {
            if (connection != null) {
                connection.close();
                log.info("Database disconnected");
            }
        } catch(SQLException ex){
            log.error("Error during database disconnection: {}", ex.getMessage());
        }
    }
}

====================
FILE: MailDAO.java

package database;

import mail.Mail;
import lombok.extern.log4j.Log4j2;
import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.Record;
import user.credential.User;
import user.manager.UserManager;

import java.util.ArrayList;
import java.util.List;

import static org.jooq.impl.DSL.field;
import static org.jooq.impl.DSL.table;

@Log4j2
public class MailDAO {
    private final DSLContext create;
    private final String MAILS_TABLE = "mails";
    private final UserDAO userDAO;

    public MailDAO(DSLContext create, UserDAO userDAO) {
        this.create = create;
        this.userDAO = userDAO;
    }

    public void saveMailToDB(Mail mail) {
        create.insertInto(table(MAILS_TABLE),
                        field("sender_name"),
                        field("recipient_name"),
                        field("message"),
                        field("status"))
                .values(mail.getSender().getUsername(),
                        mail.getRecipient().getUsername(),
                        mail.getMessage(),
                        mail.getStatus().toString())
                .execute();
    }

    public List<Mail> getMailsFromDB(String boxType) {
        List<Record> records = create.selectFrom(MAILS_TABLE)
                .where(getMailboxCondition(boxType))
                .fetch();

        List<Mail> mails = new ArrayList<>();
        for (Record record : records) {
            Mail mail = convertRecordToMail(record);
            mails.add(mail);
        }
        return mails;
    }

    public void deleteMailsFromDB(String boxType) {
        create.deleteFrom(table(MAILS_TABLE))
                .where(getMailboxCondition(boxType))
                .execute();
    }

    public Mail convertRecordToMail(Record record) {
        String message = record.getValue("message", String.class);
        String senderUsername = record.getValue("sender_name", String.class);
        String recipientUsername = record.getValue("recipient_name", String.class);
        Mail.Status status = Mail.Status.valueOf(record.getValue("status", String.class));

        User sender = userDAO.getUserFromDB(senderUsername);
        User recipient = userDAO.getUserFromDB(recipientUsername);

        return new Mail(sender, recipient, message, status);
    }

    public Condition getMailboxCondition(String boxType) {
        String username = UserManager.currentLoggedInUser.getUsername();
        Condition condition;

        if (boxType.equals(Mail.Status.SENT.toString())) {
            condition = field("sender_name").eq(username)
                    .and(field("status").eq(boxType));
        } else {
            condition = field("recipient_name").eq(username)
                    .and(field("status").eq(boxType));
        }

        return condition;
    }

    public boolean isMailboxFullInDB(User recipient){
        String unread = Mail.Status.UNREAD.toString();

        int messageCount = create.selectFrom(table(MAILS_TABLE))
                .where(field("recipient_name").eq(recipient.getUsername())
                        .and(field("status").eq(unread)))
                .fetch()
                .size();

        return messageCount > 5;
    }

    public void markAsReadInDB() {
        log.info("Marking mails as read");

        create.update(table(MAILS_TABLE))
                .set(field("status"), Mail.Status.OPENED.toString())
                .where(field("recipient_name").eq(UserManager.currentLoggedInUser.getUsername()))
                .and(field("status").eq(Mail.Status.UNREAD.toString()))
                .execute();

        log.info("Marked all unread mails as opened for user {}", UserManager.currentLoggedInUser.getUsername());
    }
}

====================
FILE: UserDAO.java

package database;

import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.Record;
import org.jooq.impl.DSL;
import org.mindrot.jbcrypt.BCrypt;
import user.credential.User;

import static org.jooq.impl.DSL.field;
import static org.jooq.impl.DSL.table;

@Log4j2
public class UserDAO {
    private final DSLContext create;
    private final String USERS_TABLE = "users";

    public UserDAO(DSLContext create) {
        this.create = create;
    }

    public void addUserToDB(User user)  {
        create.insertInto(table(USERS_TABLE),
                        field("username"),
                        field("password"),
                        field("role"),
                        field("hashed_password"))
                .values(user.getUsername(),
                        user.getPassword(),
                        user.getRole().toString(),
                        user.getHashedPassword())
                .execute();
    }

    public User getUserFromDB(String username) {
        Record record = create.selectFrom(USERS_TABLE)
                .where(DSL.field("username").eq(username))
                .fetchOne();

        if (record == null) {
            return null;
        }

        return new User(
                record.getValue("username", String.class),
                record.getValue("password", String.class),
                User.Role.valueOf(record.getValue("role", String.class).toUpperCase())
        );
    }

    public boolean checkPasswordInDB(String typedPassword, String username) {
        Record record = create.selectFrom("users")
                .where(DSL.field("username").eq(username))
                .fetchOne();

        String hashed = record.getValue("hashed_password", String.class);

        return BCrypt.checkpw(typedPassword, hashed);
    }

    public void deleteUserFromDB(String username) {
        create.deleteFrom(table(USERS_TABLE))
                .where(field("username").eq(username))
                .execute();
    }

    public void changeUserRoleInDB(User user, User.Role role) {
        user.setRole(role);
        updateUserInDB(user);
    }

    public void updateUserInDB(User user) {
        create.update(table(USERS_TABLE))
                .set(field("password"), user.getPassword())
                .set(field("role"), user.getRole().toString())
                .set(field("hashed_password"), user.getHashedPassword())
                .where(field("username").eq(user.getUsername()))
                .execute();
    }
}

====================
FILE: AuthHandler.java

package handler.auth;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.manager.UserManager;

/**
 * The AuthHandler class processes authentication requests such as REGISTER and LOGIN.
 * It interacts with the UserManager to handle these operations and generate appropriate responses.
 */

@Log4j2
public class AuthHandler {

    /**
     * Processes authentication requests (REGISTER, LOGIN) and generates appropriate responses.
     * @param requestCommand The command for the request (e.g., "REGISTER", "LOGIN")
     */
     public String getResponse(String requestCommand, String username, String password, UserManager userManager)  {
         log.info("Processing authentication request: {}", requestCommand);
         switch (requestCommand) {
            case "REGISTER":
                return userManager.registerAndGetResponse(username, password);
            case "LOGIN":
                return userManager.loginAndGetResponse(username, password);
             default:
                 log.warn("Unknown request: {}", requestCommand);
                 return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }
}

====================
FILE: LogoutHandler.java

package handler.auth;

import lombok.extern.log4j.Log4j2;
import user.manager.UserManager;

@Log4j2
public class LogoutHandler {
    public String getResponse(UserManager userManager)  {
        log.info("Attempting to log out user: {}", UserManager.currentLoggedInUser.getUsername());
        return userManager.logoutAndGetResponse();
    }
}

====================
FILE: HandlerFactory.java

package handler;

import lombok.Getter;
import lombok.Setter;

import handler.user.PasswordChangeHandler;
import handler.user.RoleChangeHandler;
import handler.user.UserDeleteHandler;
import handler.user.UserSwitchHandler;
import handler.auth.AuthHandler;
import handler.auth.LogoutHandler;
import handler.mail.MailboxHandler;
import handler.mail.WriteHandler;
import handler.server.ServerDetailsHandler;
@Getter
@Setter
public class HandlerFactory {
    private AuthHandler authHandler;
    private ServerDetailsHandler serverInfoHandler;
    private MailboxHandler mailHandler;
    private WriteHandler writeHandler;
    private LogoutHandler logoutHandler;
    private PasswordChangeHandler passwordHandler;
    private RoleChangeHandler roleHandler;
    private UserDeleteHandler deleteHandler;
    private UserSwitchHandler switchHandler;

    public HandlerFactory(){
        this.authHandler = new AuthHandler();
        this.serverInfoHandler = new ServerDetailsHandler();
        this.mailHandler = new MailboxHandler();
        this.writeHandler = new WriteHandler();
        this.passwordHandler = new PasswordChangeHandler();
        this.roleHandler = new RoleChangeHandler();
        this.deleteHandler = new UserDeleteHandler();
        this.switchHandler = new UserSwitchHandler();
        this.logoutHandler = new LogoutHandler();
    }
}

====================
FILE: MailboxHandler.java

package handler.mail;

import java.io.IOException;
import java.util.List;

import lombok.extern.log4j.Log4j2;
import mail.Mail;
import mail.MailService;
import shared.ResponseMessage;

/**
 * The MailboxHandler class handles mailbox operations such as reading and deleting mails.
 * It uses the MailService to perform the operations and generate appropriate responses.
 */

@Log4j2
public class MailboxHandler {
    private MailService mailService = new MailService();

    /**
     * Processes mailbox operations (READ, DELETE) and generates appropriate responses.
     * @param mailboxOperation The mailbox operation command (e.g., "READ", "DELETE")
     * @param boxType The type of mailbox (e.g., "UNREAD", "OPENED")
     */
    public String getResponse(String mailboxOperation, String boxType) throws IOException {
        log.info("Processing mailbox operation: {}", mailboxOperation);

        switch (mailboxOperation) {
            case "READ":
                return getReadResponse(boxType);
            case "DELETE":
                return getDeleteMailsResponse(boxType);
            default:
                log.warn("Unknown mail operation: {}", mailboxOperation);
                return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }

    /**
     * Generates the response for reading mails from the specified mailbox.
     */
    private String getReadResponse(String boxType) {
        log.info("Reading mails from box: {}", boxType);
        List<Mail> mailsToRead = mailService.getMails(boxType);

        if (mailsToRead.isEmpty()) {
            return ResponseMessage.MAILBOX_EMPTY.getResponse();
        }

        // Mail reading
        StringBuilder response = new StringBuilder();
        for (Mail mail : mailsToRead) {
            response.append("From: ")
                    .append(mail.getSender().getUsername())
                    .append("\n Message: ")
                    .append(mail.getMessage())
                    .append("\n");
        }

        if(boxType.equals(Mail.Status.UNREAD.toString())){
            mailService.markAsRead();
        }

        return response.toString();
    }

    private String getDeleteMailsResponse(String boxType){
        log.info("Deleting mails from box: {}", boxType);
        mailService.deleteMails(boxType);
        return ResponseMessage.MAIL_DELETION_SUCCEEDED.getResponse();
    }
}

====================
FILE: WriteHandler.java

package handler.mail;

import java.io.IOException;

import lombok.extern.log4j.Log4j2;
import mail.MailService;
import shared.ResponseMessage;
import user.credential.User;
import user.manager.UserManager;

/**
 * The WriteHandler class processes requests to send mail.
 * It interacts with the MailService and UserManager to send emails and handle related validations.
 */

@Log4j2
public class WriteHandler {
    private MailService mailService = new MailService();

    /**
     * Processes a request to send mail and generates an appropriate response.
     * @param username The username of the recipient
     * @param message The message to be sent
     */
    public String getResponse(String username, String message, UserManager userManager) throws IOException {
        log.info("Attempting to send mail to user: {}", username);

        User recipient = userManager.getUserByUsername(username);

        if (recipient == null) {
            log.warn("Mail sending failed, recipient not found: {}", username);
            return ResponseMessage.SENDING_FAILED_RECIPIENT_NOT_FOUND.getResponse();
        }

        if(mailService.isMailboxFull(recipient)){
            log.warn("Mail sending failed, recipient's {} mailbox is full: ", username);
            return ResponseMessage.SENDING_FAILED_BOX_FULL.getResponse();
        }

        if(message.length() >= 255) {
            log.warn("Mail sending failed, message too long for recipient: {}", username);
            return ResponseMessage.SENDING_FAILED_TO_LONG_MESSAGE.getResponse();
        }

        mailService.sendMail(recipient, message);

        log.info("Mail sent successfully to: {}", username);
        return ResponseMessage.SENDING_SUCCEEDED.getResponse();
    }
}

====================
FILE: ServerDetailsHandler.java

package handler.server;

import lombok.extern.log4j.Log4j2;
import server.ServerDetails;
import shared.ResponseMessage;

/**
 * The ServerDetailsHandler class provides responses for server information requests.
 * It can return server uptime, version, and available commands.
 */

@Log4j2
public class ServerDetailsHandler {
    private final ServerDetails serverInfo = new ServerDetails();

    public String getResponse(String requestCommand) {
        log.info("Received info request command: {}", requestCommand);
        return getFormattedServerInfo(requestCommand);
    }

    private String getFormattedServerInfo(String request) {
        StringBuilder builder = new StringBuilder();
        switch (request.toUpperCase()) {
            case "UPTIME":
                builder.append("Uptime:\n");
                builder.append(String.format("%d days, %d hours, %d minutes, %d seconds",
                        serverInfo.getUptime().get("Days"),
                        serverInfo.getUptime().get("Hours"),
                        serverInfo.getUptime().get("Minutes"),
                        serverInfo.getUptime().get("Seconds")));
                return builder.toString();
            case "INFO":
                builder.append("Server Info:\n");
                serverInfo.getServerDetails().forEach((key, value) -> builder.append(key).append(" = ").append(value).append("\n"));
                return builder.toString();
            case "HELP":
                builder.append("Available Commands:\n");
                serverInfo.getCommands().forEach((key, value) -> builder.append(key).append(" - ").append(value).append("\n"));
                return builder.toString();
            default:
                log.warn("Unknown server info request: {}", request);
                return ResponseMessage.UNKNOWN_REQUEST.getResponse();
        }
    }
}

====================
FILE: PasswordChangeHandler.java

package handler.user;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.credential.User;
import user.manager.UserManager;

/**
 * The PasswordChangeHandler class handles user passwords changing by admin.
 * It ensures the current user is authorized to perform these operations.
 */

@Log4j2
public class PasswordChangeHandler {
    public String getResponse(String username, String newPassword, UserManager userManager) {
        log.info("Attempting to change password for user: {}", username);

        if(userManager.isUserAdmin()){
            User user = userManager.getUserByUsername(username);
            if (user == null) {
                log.warn("Failed to find user: {}", username);
                return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
            }

            userManager.changePassword(user, newPassword);

            log.info("Password changed successfully for user: {}", username);
            return ResponseMessage.OPERATION_SUCCEEDED.getResponse();
        } else {
            log.warn("Authorization failed for password change for user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: RoleChangeHandler.java

package handler.user;
import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.credential.User;
import user.manager.UserManager;

/**
 * The RoleChangeHandler class handles user role changing by admin.
 * It ensures the current user is authorized to perform these operations.
 */

@Log4j2
public class RoleChangeHandler {
    public String getResponse(String username, User.Role role, UserManager userManager) {
        log.info("Attempting to change role for user: {}", username);

        if(userManager.isUserAdmin()){
            User user = userManager.getUserByUsername(username);
            if (user == null) {
                log.warn("Failed to find user: {}", username);
                return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
            }

            userManager.changeUserRole(user, role);

            log.info("Role change succeeded: {}", username);
            return ResponseMessage.ROLE_CHANGE_SUCCEEDED.getResponse();
        } else {
            log.warn("Authorization failed for password change for user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: UserDeleteHandler.java

package handler.user;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.credential.User;
import user.manager.UserManager;

/**
 * The UserDeleteHandler class handles user account deletion by admin.
 * It ensures the current user is authorized to perform these operations.
 */

@Log4j2
public class UserDeleteHandler {
    public String getResponse(String username, UserManager userManager) {
        log.info("Attempting to delete user: {}", username);

        if(userManager.isUserAdmin()){
            User user = userManager.getUserByUsername(username);

            if (user == null) {
                log.warn("Failed to find user: {}", username);
                return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
            }

            userManager.deleteUser(user);

            log.info("User account deletion succeeded: {}", username);
            return ResponseMessage.OPERATION_SUCCEEDED.getResponse();
        } else {
            log.warn("Authorization failed for password change for user: {}", username);
            return ResponseMessage.AUTHORIZATION_FAILED.getResponse();
        }
    }
}

====================
FILE: UserSwitchHandler.java

package handler.user;

import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.credential.User;
import user.manager.UserManager;

/**
 * The AdminSwitchHandler class handles requests to switch the any user account.
 * The operation permitted only for admin.
 * It verifies the current user is authorized to perform the switch.
 */

@Log4j2
public class UserSwitchHandler {

    public String getResponse(String username, UserManager userManager) {
        log.info("Attempting to switch admin to user: {}", username);

        User user = userManager.getUserByUsername(username);

        if (user == null) {
            log.warn("User not found: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse() + ": user not found";
        }

        if (!userManager.isUserAdmin()) {
            log.warn("Non-admin user attempted switch: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse() + ": non-admin user";
        }

        userManager.switchUser(user);

        if (UserManager.ifAdminSwitched) {
            log.info("Switch succeeded: {}", username);
            return ResponseMessage.SWITCH_SUCCEEDED.getResponse();
        } else {
            log.warn("Switch failed: {}", username);
            return ResponseMessage.SWITCH_FAILED.getResponse();
        }
    }
}

====================
FILE: Mail.java

package mail;

import lombok.Getter;
import lombok.Setter;
import user.credential.User;
@Getter
@Setter
public class Mail {

    public enum Status{
        UNREAD,
        OPENED,
        SENT;
    }

    private User sender;
    private User recipient;
    private String message;
    private Status status;

    public Mail(User sender, User recipient, String message, Status status) {
        this.sender = sender;
        this.recipient = recipient;
        this.message = message;
        this.status = status;
    }
}

====================
FILE: MailService.java

package mail;

import database.DatabaseConnection;
import database.MailDAO;
import database.UserDAO;
import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import user.credential.User;
import user.manager.UserManager;

import java.util.List;

@Log4j2
public class MailService {
    private final DSLContext create;
    private final MailDAO mailDAO;
    private UserDAO userDAO;

    public MailService() {
        this.create = DSL.using(DatabaseConnection.getInstance().getConnection());
        this.userDAO = new UserDAO(create);
        this.mailDAO = new MailDAO(create, userDAO);
    }

    public void sendMail(User recipient, String message) {
        log.info("Mail sending to {} from {}", recipient, UserManager.currentLoggedInUser);

        Mail mailToSender = new Mail(UserManager.currentLoggedInUser, recipient, message, Mail.Status.SENT);
        mailDAO.saveMailToDB(mailToSender);

        Mail mailToRecipient = new Mail(mailToSender.getSender(), recipient, message, Mail.Status.UNREAD);
        mailDAO.saveMailToDB(mailToRecipient);

        log.info("Mail successfully sent to {}", recipient.getUsername());
    }

    public List<Mail> getMails(String boxType) {
        log.info("Entering getMails method with boxType: {}", boxType);
        return mailDAO.getMailsFromDB(boxType);
    }

    public boolean isMailboxFull(User recipient){
        return mailDAO.isMailboxFullInDB(recipient);
    }


    public void deleteMails(String boxType) {
        log.info("Deleting mails from box: {}", boxType);

        mailDAO.deleteMailsFromDB(boxType);

        log.info("{} mails deleted for user {}", boxType, UserManager.currentLoggedInUser.getUsername());
    }

    public void markAsRead() {
        log.info("Marking mails as read");

        mailDAO.markAsReadInDB();

        log.info("Marked all unread mails as opened for user {}", UserManager.currentLoggedInUser.getUsername());
    }
}

====================
FILE: Request.java

package request;

import lombok.Getter;
import lombok.Setter;
import user.credential.User;

@Getter
@Setter
public class Request {
    private String requestCommand;
    private String username;
    private String password;
    private String recipient;
    private String message;
    private String boxOperation;
    private String boxType;
    private String userToUpdate;
    private String newPassword;
    private String userToSwitch;
    private User.Role newRole;
}


====================
FILE: RequestFactory.java

package request;

import lombok.extern.log4j.Log4j2;
import user.credential.User;

/**
 * The RequestFactory class creates different types of Request objects based on the command.
 * It includes methods for creating authentication, server details, mailbox, and account update requests.
 */

@Log4j2
public class RequestFactory {
    private Request request;

    public RequestFactory() {
        this.request = new Request();
    }

    public Request createAuthRequest(String requestCommand, String username, String password) {
        request.setRequestCommand(requestCommand);
        request.setUsername(username);
        request.setPassword(password);
        log.info("AuthRequest created for user: {}", username);
        return request;
    }

    public Request createLogoutRequest(String requestCommand) {
        request.setRequestCommand(requestCommand);
        log.info("LogoutRequest created with command: {}", requestCommand);
        return request;
    }

    /**
     * Creates a server details request.
     * @param requestCommand The request command (e.g., "INFO", "UPTIME")
     */
    public Request createServerDetailsRequest(String requestCommand) {
        request.setRequestCommand(requestCommand);
        log.info("ServerDetailsRequest created with command: {}", requestCommand);
        return request;
    }

    /**
     * Creates a write (send mail) request.
     * @param requestCommand The request command ("WRITE")
     */
    public Request createWriteRequest(String requestCommand, String recipient, String message) {
        request.setRequestCommand(requestCommand);
        request.setRecipient(recipient);
        request.setMessage(message);
        log.info("WriteRequest created for recipient: {}", recipient);
        return request;
    }

    /**
     * Creates a boxType operation request.
     * @param requestCommand The request command ("MAILBOX")
     * @param boxOperation The boxType operation (e.g., "READ", "DELETE")
     * @param boxType The boxType type (e.g., "UNREAD", "SENT")
     */
    public Request createMailBoxRequest(String requestCommand, String boxOperation, String boxType) {
        request.setRequestCommand(requestCommand);
        request.setBoxOperation(boxOperation);
        request.setBoxType(boxType);
        log.info("MailBoxRequest created with operation: {} for boxType: {}", boxOperation, boxType);
        return request;
    }

    /**
     * Creates an admin password change request.
     * @param updateOperation The update operation ("PASSWORD")
     */
    public Request createAdminChangePasswordRequest(String updateOperation, String userToUpdate, String newPassword) {
        request.setRequestCommand(updateOperation);
        request.setUserToUpdate(userToUpdate);
        request.setNewPassword(newPassword);
        log.info("AdminChangePasswordRequest created for user: {}", userToUpdate);
        return request;
    }


    public Request createDeleteUserRequest(String updateOperation, String userToDelete) {
        request.setRequestCommand(updateOperation);
        request.setUserToUpdate(userToDelete);
        log.info("AdminDeleteUserRequest created for user: {}", userToDelete);
        return request;
    }

    public Request createChangeRoleRequest(String updateOperation, String userToUpdate, User.Role role) {
        request.setRequestCommand(updateOperation);
        request.setUserToUpdate(userToUpdate);
        request.setNewRole(role);
        log.info("AdminChangeRoleRequest created for user: {} with new role: {}", userToUpdate, role);
        return request;
    }

    /**
     * Creates an admin switch user request.
     * @param requestCommand The request command ("SWITCH")
     */
    public Request createSwitchUserRequest(String requestCommand, String userToSwitch) {
        request.setRequestCommand(requestCommand);
        request.setUserToSwitch(userToSwitch);
        log.info("AdminSwitchUserRequest created for user: {}", userToSwitch);
        return request;
    }
}

====================
FILE: RequestService.java

package request;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import client.ClientConnection;
import lombok.extern.log4j.Log4j2;
import shared.UserInteraction;
import user.credential.User;

@Log4j2
public class RequestService {

    private BufferedReader userInput;
    private UserInteraction userInteraction;
    private ClientConnection connection;
    private RequestFactory factory;

    public RequestService(ClientConnection clientConnection) {
        this.connection = clientConnection;
        this.userInput = new BufferedReader(new InputStreamReader(System.in));
        this.userInteraction = new UserInteraction(userInput);
        this.factory = new RequestFactory();
        log.info("RequestFactory instance created");
    }

    /**
     * Creates a request based on the current connection state (logged in or not).
     * Delegates to the appropriate menu request handler.
     */
    public Request getRequest(String requestCommand) throws IOException {
        log.info("Creating request for command: {}", requestCommand);

        if(!connection.isLoggedIn()){
            return getLoginMenuRequest(requestCommand);
        } else {
            return getMailboxMenuRequest(requestCommand);
        }
    }

    public Request getLoginMenuRequest(String requestCommand) throws IOException {
        switch (requestCommand.toUpperCase()) {
            case "REGISTER":
            case "LOGIN":
                String username = userInteraction.getUsername();
                String password = userInteraction.getPassword();
                return factory.createAuthRequest(requestCommand, username, password);
            case "HELP":
            case "INFO":
            case "UPTIME":
                return factory.createServerDetailsRequest(requestCommand);
            case "LOGOUT":
                return factory.createLogoutRequest(requestCommand);
            default:
                log.warn("Unknown login menu request: {}", requestCommand);
                return null;
        }
    }

    public Request getMailboxMenuRequest(String requestCommand) throws IOException {
        switch (requestCommand.toUpperCase()){
            case "WRITE":
                String recipient = userInteraction.getRecipient();
                String message = userInteraction.getMessage();
                return factory.createWriteRequest(requestCommand, recipient, message);
            case "MAILBOX":
                String boxOperation = userInteraction.chooseBoxOperation();
                String boxType = userInteraction.chooseBoxType();
                return factory.createMailBoxRequest(requestCommand, boxOperation, boxType);
            case "UPDATE":
                return getAccountUpdateRequest();
            case "SWITCH":
                String userToSwitch = userInteraction.getUserToSwitch();
                return factory.createSwitchUserRequest(requestCommand, userToSwitch);
            case "LOGOUT":
                return factory.createLogoutRequest(requestCommand);
            default:
                log.warn("Unknown boxType menu request: {}", requestCommand);
                return null;
        }
    }

    /**
     * Ensures the current user is authorized to perform the update.
     */
    public Request getAccountUpdateRequest() throws IOException {
        log.info("Creating account update request");

        if (connection.isAuthorized()) {
            log.info("Authorization succeeded");
            String updateOperation = userInteraction.chooseUpdateOperation();
            String userToUpdate = userInteraction.chooseUserToUpdate();
            switch (updateOperation.toUpperCase()) {
                case "PASSWORD":
                    String newPassword = userInteraction.getNewPassword();
                    return factory.createAdminChangePasswordRequest(updateOperation, userToUpdate, newPassword);
                case "DELETE":
                    return factory.createDeleteUserRequest(updateOperation, userToUpdate);
                case "ROLE":
                    User.Role newRole = userInteraction.chooseRole();
                    return factory.createChangeRoleRequest(updateOperation, userToUpdate, newRole);
                default:
                    log.warn("Unknown update operation: {}", updateOperation);
                    return null;
            }
        }
        log.warn("Authorization failed");
        return null;
    }
}

====================
FILE: Server.java

package server;

import database.DatabaseConnection;
import lombok.extern.log4j.Log4j2;

@Log4j2
public class Server {
    private static final int PORT = 5000;
    public static void main(String[] args) {
        log.info("Starting server on port {}", PORT);
        ServerConnection connectionHandler = new ServerConnection(PORT);
        connectionHandler.startServer();
        ServerRequestService logicHandler = new ServerRequestService(
                connectionHandler.getOutToClient(),
                connectionHandler.getInFromClient());

        logicHandler.handleClientRequest();

        try {
            logicHandler.handleClientRequest();
        } finally {
            connectionHandler.closeConnections();
            DatabaseConnection.getInstance().disconnect();
        }

    }
}

====================
FILE: ServerConnection.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Date;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

/*
 * The ServerConnection class is responsible for managing server connections.
 * It starts the server, establishes connections with clients, and handles communication streams.
 */

@Log4j2
@Getter
@Setter
public class ServerConnection {
    private int port;
    public static Date serverTimeCreation;
    private ServerSocket serverSocket;
    private Socket clientSocket;
    private BufferedReader inFromClient;
    private PrintWriter outToClient;

    public ServerConnection(int port) {
        this.port = port;
    }

    public void startServer(){
        try{
            log.info("Starting server on port {}", port);
            serverTimeCreation = new Date();
            serverSocket = new ServerSocket(port);
            log.info("Server socket created on port {}", port);
            clientSocket = serverSocket.accept();
            log.info("Connection with client established");
            inFromClient = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
            outToClient = new PrintWriter(clientSocket.getOutputStream(), true);
        } catch (IOException ex){
            log.error("Error starting server on port {}: {}", port, ex.getMessage());
        }
    }

    public BufferedReader getInFromClient() {
        return inFromClient;
    }

    public PrintWriter getOutToClient() {
        return outToClient;
    }

    public void closeConnections() {
        try {
            log.info("Closing server and client connections");
            if (inFromClient != null) {
                inFromClient.close();
            }
            if (outToClient != null) {
                outToClient.close();
            }
            if (clientSocket != null) {
                clientSocket.close();
            }
            if (serverSocket != null) {
                serverSocket.close();
            }
            log.info("Server disconnected");
        } catch (IOException ex) {
            log.error("Error closing connections: {}", ex.getMessage());
        }
    }
}

====================
FILE: ServerDetails.java

package server;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

/**
 * The ServerDetails class provides information about the server.
 * It includes server version, available commands, and server uptime.
 */

@Getter
@Setter
@Log4j2
public class ServerDetails {
    private final String VERSION = "1.0.0";
    private Map<String, String> commands = new LinkedHashMap<>();
    private Map<String, String> serverDetails = new LinkedHashMap<>();
    private Map<String, Long> uptime = new LinkedHashMap<>();

    public ServerDetails() {
        log.info("Initializing server details");
        setCommands();
        setServerDetails();
        setUptime();
    }

   public void setUptime(){
       log.info("Setting server uptime");
       Date currentTime = new Date();
       long uptimeInMillis = currentTime.getTime() - ServerConnection.serverTimeCreation.getTime();

       long days = TimeUnit.MILLISECONDS.toDays(uptimeInMillis);
       long hours = TimeUnit.MILLISECONDS.toHours(uptimeInMillis) % 24;
       long minutes = TimeUnit.MILLISECONDS.toMinutes(uptimeInMillis) % 60;
       long seconds = TimeUnit.MILLISECONDS.toSeconds(uptimeInMillis) % 60;

       uptime.put("Days", days);
       uptime.put("Hours", hours);
       uptime.put("Minutes", minutes);
       uptime.put("Seconds", seconds);

       log.info("Server uptime set to: {} days, {} hours, {} minutes, {} seconds", days, hours, minutes, seconds);
    }

    public void setCommands() {
        log.info("Setting server commands");
        commands.put("Login", "Login to your account");
        commands.put("Register", "Create a new user account");
        commands.put("Help", "All commands list");
        commands.put("Uptime", "Check server uptime");
        commands.put("Info", "Server version and date");
        commands.put("Exit", "Stop server and client");

        log.info("Server commands set: {}", commands.keySet());
    }

    public void setServerDetails() {
        log.info("Setting server details");
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
        String setupTimeFormatted = dateFormat.format(ServerConnection.serverTimeCreation);
        serverDetails.put("Version", VERSION);
        serverDetails.put("Setup time", setupTimeFormatted);

        log.info("Server details set: {}", serverDetails);
    }
}

====================
FILE: ServerRequestService.java

package server;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;

import com.google.gson.Gson;
import handler.HandlerFactory;
import lombok.extern.log4j.Log4j2;
import request.Request;
import shared.JsonConverter;
import user.manager.UserManager;

 /**
  * The ServerRequestService class is responsible for handling various client requests
  * It manages user authentication, mail operations, user account updates, account switch, and server information
  */

@Log4j2
public class ServerRequestService {
    private final PrintWriter outToClient;
    private final BufferedReader inFromClient;
    private final UserManager userManager;
    private Gson gson;
    private JsonConverter jsonResponse;
     private HandlerFactory handler;


    public ServerRequestService(PrintWriter outToClient, BufferedReader inFromClient) {
        this.outToClient = outToClient;
        this.inFromClient = inFromClient;
        this.userManager = new UserManager();
        this.gson = new Gson();
        this.handler = new HandlerFactory();
    }

    public void handleClientRequest() {
        String request;
        try {
            while ((request = inFromClient.readLine()) != null) {
                Request req = getParseRequest(request);
                String response = processRequest(req);
                sendResponse(response);
            }
        } catch (IOException ex) {
            log.error("IOException occurred while processing the request: {}. Error: ", ex.getMessage());
        }
    }

    public Request getParseRequest(String request){
        log.info("Parsing request: {}", request);
        return gson.fromJson(request, Request.class);
    }

     public String processRequest(Request req) throws IOException{
         String command = req.getRequestCommand().toUpperCase();
         log.info("Handling request command: {}", command);
         switch (command) {
             case "REGISTER":
             case "LOGIN":
                 return handler.getAuthHandler().getResponse(command, req.getUsername(), req.getPassword(), userManager);
             case "HELP":
             case "INFO":
             case "UPTIME":
                 return handler.getServerInfoHandler().getResponse(command);
             case "WRITE":
                 return handler.getWriteHandler().getResponse(req.getRecipient(), req.getMessage(), userManager);
             case "MAILBOX":
                 return handler.getMailHandler().getResponse(req.getBoxOperation(), req.getBoxType());
             case "PASSWORD":
                 return handler.getPasswordHandler().getResponse(req.getUserToUpdate(), req.getNewPassword(), userManager);
             case "DELETE":
                 return handler.getDeleteHandler().getResponse(req.getUserToUpdate(), userManager);
             case "ROLE":
                 return handler.getRoleHandler().getResponse(req.getUserToUpdate(), req.getNewRole(), userManager);
             case "SWITCH":
                 return handler.getSwitchHandler().getResponse(req.getUserToSwitch(), userManager);
             case "LOGOUT":
                 return handler.getLogoutHandler().getResponse(userManager);
             default:
                 log.warn("Unknown request command: {}", command);
                 return "Unknown request command";
         }
     }

    public void sendResponse(String response){
        jsonResponse = new JsonConverter(response);
        String json = jsonResponse.serializeMessage();
        outToClient.println(json);
        log.info("Response sent: {}", json);
    }
}

====================
FILE: JsonConverter.java

package shared;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;

import lombok.extern.log4j.Log4j2;

@Log4j2
public class JsonConverter {
    private String message;

    public JsonConverter(String message) {
        this.message = message;
    }

    public String serializeMessage() {
        log.info("Serializing message");
        try {
            Gson gson = new Gson();
            return gson.toJson(this) + "\n<<END>>";
        } catch (Exception e) {
            throw new IllegalStateException("Error - failed to serialize JsonResponse to JSON", e);
        }
    }

    public static String deserializeMessage(String json) {
        log.info("Deserializing message");
        if (json == null || json.trim().isEmpty()) {
            throw new IllegalArgumentException("Input JSON is null or empty");
        }
        try {
            Gson gson = new Gson();
            JsonConverter jsonConverter = gson.fromJson(json, JsonConverter.class);
            log.info("Deserialized message: {}", json);
            return jsonConverter.toString();
        } catch (JsonSyntaxException e) {
            throw new IllegalArgumentException("Error deserializing JSON. Please check syntax", e);
        }
    }

    @Override
    public String toString() {
        return message;
    }
}

====================
FILE: ResponseMessage.java

package shared;

import lombok.extern.log4j.Log4j2;

/**
 * The ResponseMessage enum defines various response
 * The messages is sent from the server to the client.
 */
@Log4j2
public enum ResponseMessage {

    // General responses
    OPERATION_SUCCEEDED("Operation succeeded"),
    OPERATION_FAILED("Operation failed"),
    FAILED_TO_FIND_USER("Failed to find user"),

    // Register responses
    REGISTRATION_SUCCESSFUL("Registration successful"),
    REGISTRATION_FAILED_USER_EXISTS("Registration failed: User already exists"),

    // Login responses
    USER_LOGIN_SUCCEEDED("User login successful"),
    ADMIN_LOGIN_SUCCEEDED("Admin login successful"),
    LOGIN_FAILED_INCORRECT_PASSWORD("Login failed: Incorrect password"),

    // Logout response
    LOGOUT_SUCCEEDED("Logout succeeded"),

    // Authorization responses
    AUTHORIZATION_SUCCEEDED("Authorization succeeded"),
    AUTHORIZATION_FAILED("Authorization failed"),

    // Account switch responses
    SWITCH_SUCCEEDED("Switch succeeded"),
    SWITCH_FAILED("Switch failed"),

    // Role change responses
    ROLE_CHANGE_SUCCEEDED("Role change succeeded"),
    ROLE_CHANGE_FAILED("Role change failed"),

    // Mail responses
    SENDING_SUCCEEDED("Sending succeeded"),
    SENDING_FAILED_BOX_FULL("Sending failed: Recipient's mailbox is full"),
    SENDING_FAILED_TO_LONG_MESSAGE("Sending failed: Message too long (maximum 255 characters)"),
    SENDING_FAILED_RECIPIENT_NOT_FOUND("Sending failed: Recipient not found"),
    MAIL_DELETION_SUCCEEDED("Mails deletion succeeded"),
    MAILBOX_EMPTY("Mailbox is empty"),

    // Unknown Message
    UNKNOWN_REQUEST("Unknown request"),
    UNKNOWN_RESPONSE("Unknown response");

    private final String RESPONSE;

    ResponseMessage(String response){
        this.RESPONSE = response;
    }

    public String getResponse() {
        return RESPONSE;
    }

 /**
  * Converts a string to the corresponding ResponseMessage enum value
  * Iterate over all the values in the ResponseMessage enum
  * Check if the 'response' field of the current enum value matches the input text
  * If a match is found, return the corresponding ResponseMessage enum value
  */
 public static ResponseMessage fromString(String text) {
        log.info("Converting text to OperationResponses: {}", text);
        for (ResponseMessage message : ResponseMessage.values()) {
            if (message.getResponse().equals(text)) {
                log.info("Match found for text: {}", text);
                return message;
            }
        }
        log.warn("No match found for text: {}", text);
        return UNKNOWN_RESPONSE;
    }
}


====================
FILE: Screen.java

package shared;

public class Screen {

    public static void printLoginMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              Welcome in MailBox!            |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Register                                    |\n" +
                "| Login                                       |\n" +
                "| Uptime                                      |\n" +
                "| Info                                        |\n" +
                "| Help                                        |\n" +
                "| Exit                                        |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printAdminMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Update                                      |\n" +
                "| Switch                                      |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }

    public static void printUserMailBoxMenu() {
        System.out.println("+---------------------------------------------+\n" +
                "|              You are logged in              |\n" +
                "|                                             |\n" +
                "| Select:                                     |\n" +
                "|                                             |\n" +
                "| Write mail                                  |\n" +
                "| Mailbox                                     |\n" +
                "| Logout                                      |\n" +
                "+---------------------------------------------+");
        System.out.print("Select an option: ");
    }
}

====================
FILE: UserInteraction.java

package shared;

import java.io.BufferedReader;
import java.io.IOException;

import user.credential.User.Role;

/**
 * The UserInteraction class provides methods to interact with the user through the console.
 * It prompts the user for various inputs required for creating requests.
 */

public class UserInteraction {
    private BufferedReader reader;
    public UserInteraction(BufferedReader reader) {
        this.reader = reader;
    }

    public String getUsername() throws IOException {
        System.out.print("Please type your username: ");
        return reader.readLine();
    }

    public String getPassword() throws IOException {
        System.out.print("Please type your password: ");
        return reader.readLine();
    }

    public String getNewPassword() throws IOException{
        System.out.print("Please type a new password: ");
        return reader.readLine();
    }

    public String getRecipient() throws IOException {
        System.out.print("Please type a recipient's username: ");
        return reader.readLine();
    }

    public String getMessage() throws IOException {
        System.out.println("Please type your message (max 255 characters): ");
        return reader.readLine();
    }

     public String getUserToSwitch() throws IOException {
         System.out.print("Please type a username to switch: ");
         return reader.readLine();
     }

    public String chooseBoxOperation() throws IOException {
        while (true) {
            System.out.println("Mailbox operation: READ / DELETE: ");
            System.out.print("Select: ");
            String operation = reader.readLine().toUpperCase();
            switch (operation) {
                case "READ":
                case "DELETE":
                    return operation;
                default:
                    System.out.println("Invalid operation. Please try again!");;
            }
        }
    }
    public String chooseBoxType() throws IOException {
        while (true) {
                System.out.println("Mailbox type: OPENED / UNREAD / SENT");
                System.out.print("Select: ");
                String mailbox = reader.readLine().toUpperCase();
                switch (mailbox) {
                    case "OPENED":
                    case "UNREAD":
                    case "SENT":
                        return mailbox;
                    default:
                        System.out.println("Invalid mailbox type. Please try again!");
                }
        }
    }

    public String chooseUpdateOperation() throws IOException {
        while (true) {
            System.out.println("Update operations: PASSWORD / DELETE / ROLE");;
            System.out.print("Select: ");;
            String input = reader.readLine();
            switch (input.toUpperCase()) {
                case "PASSWORD":
                    return "PASSWORD";
                case "DELETE":
                    return "DELETE";
                case "ROLE":
                    return "ROLE";
                default:
                    System.out.println("Invalid operation type. Please try again!");
            }
        }
    }

    public String chooseUserToUpdate() throws IOException {
        System.out.print("Please type an username to update: ");
        return reader.readLine();
    }

    public Role chooseRole() throws IOException {
        System.out.print("Please type the new role (ADMIN / USER): ");
        String newRole = reader.readLine();
        if(newRole.equals("ADMIN")){
            return Role.ADMIN;
        } else {
            return Role.USER;
        }
    }
}

====================
FILE: Admin.java

package user.credential;

import lombok.extern.log4j.Log4j2;
import user.credential.User;

@Log4j2
public class Admin extends User {

    public Admin() {
        super("admin", "java10", Role.ADMIN);
        log.info("Admin instance created");
    }

}



====================
FILE: User.java

package user.credential;

import org.mindrot.jbcrypt.BCrypt;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;

@Getter
@Setter
@Log4j2
public class User {

    public enum Role {
        ADMIN,
        USER;
    }

    protected String username;
    protected String password;
    protected String hashedPassword;
    protected Role role;

    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        log.info("User instance created: {}", username);
    }


    public void hashPassword(){
        hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
        log.info("Password hashed for user: {}", username);
    }

    public void setPassword(String newPassword) {
        log.info("Setting new password for user: {}", username);
        this.password = newPassword;
        hashPassword();
        log.info("New password set for user: {}", username);
    }

    public String toString() {
        return username;
    }
}

====================
FILE: AuthManager.java

package user.manager;

import database.UserDAO;
import lombok.extern.log4j.Log4j2;
import shared.ResponseMessage;
import user.credential.User;

@Log4j2
public class AuthManager {
    public String registerUser(String username, String password, UserDAO userDAO) {
        log.info("Registration attempted for user: {}", username);
        User user = userDAO.getUserFromDB(username);

        if (user != null) {
            log.info("Registration attempt failed - user already exists: {}", username);
            return ResponseMessage.REGISTRATION_FAILED_USER_EXISTS.getResponse();
        }

        handleRegister(username, password, userDAO);
        log.info("Registration successful for new user: {}", username);
        return ResponseMessage.REGISTRATION_SUCCESSFUL.getResponse();
    }

    public void handleRegister(String username, String password, UserDAO userDAO) throws IllegalArgumentException {
        User newUser = new User(username, password, User.Role.USER);

        userDAO.addUserToDB(newUser);
        UserManager.currentLoggedInUser = newUser;

        log.info("User registered: {}", username);
    }

    public String loginUser(String username, String password, UserDAO userDAO) {
        log.info("Login attempted for user: {}", username);
        User user = userDAO.getUserFromDB(username);

        if (user == null) {
            log.info("Login attempt failed - user does not exist: {}", username);
            return ResponseMessage.FAILED_TO_FIND_USER.getResponse();
        }

        if (!ifPasswordCorrect(password, user, userDAO)) {
            log.info("Incorrect password attempt for user: {}", user.getUsername());
            return ResponseMessage.LOGIN_FAILED_INCORRECT_PASSWORD.getResponse();
        }

        log.info("User password correct: {}", user.getUsername());

        handleLogin(user);

        log.info("User login succeeded: {}", user.getUsername());

        if (isUserAdmin()) {
            return ResponseMessage.ADMIN_LOGIN_SUCCEEDED.getResponse();
        } else {
            return ResponseMessage.USER_LOGIN_SUCCEEDED.getResponse();
        }


    }
    public void handleLogin(User existingUser) {
        UserManager.currentLoggedInUser = existingUser;
    }

    public boolean checkPassword(String typedPassword, User user, UserDAO userDAO) {
        log.info("Checking password for user: {}", user.getUsername());

        return userDAO.checkPasswordInDB(typedPassword, user.getUsername());
    }

    public boolean ifPasswordCorrect(String password, User user, UserDAO userDAO) {
        return checkPassword(password, user, userDAO);
    }

    public boolean isUserAdmin(){
        log.info("Admin role checking for user: {}", UserManager.currentLoggedInUser.getUsername());
        return UserManager.currentLoggedInUser != null && UserManager.currentLoggedInUser.getRole().equals(User.Role.ADMIN);
    }
}

====================
FILE: UserManager.java

package user.manager;

import database.DatabaseConnection;
import database.UserDAO;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.log4j.Log4j2;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import shared.ResponseMessage;
import user.credential.Admin;
import user.credential.User;


/**
 * The UserManager class manages user accounts and operations such as registration, login, and role changes.
 * It interacts with the database to store and retrieve user information.
 */

@Log4j2
@Getter
@Setter
public class UserManager {
    public static User currentLoggedInUser;
    public static boolean ifAdminSwitched;
    public Admin admin;
    private final DSLContext create;
    private final UserDAO userDAO;
    private AuthManager authManager;

    public UserManager() {
        this.create = DSL.using(DatabaseConnection.getInstance().getConnection());
        this.userDAO = new UserDAO(create);
        this.admin = new Admin();
        this.authManager = new AuthManager();
    }

    public String registerAndGetResponse(String username, String password) {
        return authManager.registerUser(username, password, userDAO);
    }

    public String loginAndGetResponse(String username, String password) {
        return authManager.loginUser(username, password, userDAO);
    }

    public User getUserByUsername(String username) {
        log.info("Searching for user in the database: {}", username);

        User user = userDAO.getUserFromDB(username);

        if (user == null) {
            log.warn("User not found in database: {}", username);
            return null;
        }

        log.info("User found in database: {}", username);
        return user;
    }

    public void changePassword(User user, String newPassword) {
        log.info("Attempting to password change for user: {}", user.getUsername());

        user.setPassword(newPassword);

        log.info("Attempting to upload database: {}", user.getUsername());
        userDAO.updateUserInDB(user);
        log.info("Data base upload succeeded {}", user.getUsername());

        log.info("Password change succeeded for user: {}", user.getUsername());
    }

    public void deleteUser(User user) {
        log.info("Attempting to delete user: {}", user.getUsername());

        userDAO.deleteUserFromDB(user.getUsername());

        log.info("User deletion succeeded: {}", user.getUsername());
    }

    public void switchUser(User user) {
        log.info("Attempting to switch to user: {}", user.getUsername());

            UserManager.currentLoggedInUser = user;
            UserManager.ifAdminSwitched = true;

        log.info("Switched to user: {}", user.getUsername());
    }

    public void changeUserRole(User user, User.Role role) {
        log.info("Attempting to role change for user: {}", user.getUsername());

        userDAO.changeUserRoleInDB(user, role);

        log.info("Role change succeeded for user: {} to {}", user.getUsername(), role);
    }

    public String logoutAndGetResponse() {
        log.info("User logout requested");

        ifAdminSwitched = false;
        currentLoggedInUser = null;

        return ResponseMessage.LOGOUT_SUCCEEDED.getResponse();
    }

    public boolean isUserAdmin(){
        log.info("Admin role checking for user: {}", currentLoggedInUser.getUsername());
        return currentLoggedInUser != null && currentLoggedInUser.getRole().equals(User.Role.ADMIN);
    }
}

====================
FILE: ClientCommunicationTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;

import org.junit.jupiter.api.*;
import shared.ResponseMessage;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ClientCommunicationTest {
    static ClientConnection clientConnection;
    Socket mockSocket;
    PrintWriter mockOutToServer;
    BufferedReader mockInFromServer;

    @BeforeEach
    void setUp() {
        mockSocket = mock(Socket.class);
        mockOutToServer = mock(PrintWriter.class);
        mockInFromServer = mock(BufferedReader.class);
        clientConnection = new ClientConnection();
        clientConnection.setClientSocket(mockSocket);
        clientConnection.setOutToServer(mockOutToServer);
        clientConnection.setInFromServer(mockInFromServer);
    }

    @AfterAll
    static void closeDown() {
        clientConnection.disconnect();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectToServer()  {
        Assertions.assertTrue(clientConnection.isConnected());
    }

    @Test
    @DisplayName("Should test sending request")
    void testSendRequest() {
        String request = "exampleRequest";

        clientConnection.sendRequest(request);

        // Verify that the request was sent to the server
        verify(mockOutToServer).println(request);
    }

    @Test
    @DisplayName("Should test checking response status")
    void testReadResponse() throws IOException {
        String jsonResponse1 = "{\"message\":\"response1\"}";
        String jsonResponse2 = "{\"message\":\"response2\"}";

        // Mock server responses
        when(mockInFromServer.readLine())
                .thenReturn(jsonResponse1, jsonResponse2, "<<END>>");

        clientConnection.readResponse();

        // Verify that the responses were read from the server
        verify(mockInFromServer, times(3)).readLine();
    }

    @Test
    @DisplayName("Should check response status")
    void testCheckResponseStatus() {
        // Test admin login succeeded
        String response = ResponseMessage.ADMIN_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());
        assertTrue(clientConnection.isAuthorized());

        // Test user login succeeded
        response = ResponseMessage.USER_LOGIN_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test registration succeeded
        response = ResponseMessage.REGISTRATION_SUCCESSFUL.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isLoggedIn());

        // Test logout succeeded
        response = ResponseMessage.LOGOUT_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isLoggedIn());
        assertFalse(clientConnection.isAuthorized());
        assertFalse(clientConnection.isAdminSwitchedAndAuthorized());

        // Test authorization succeeded
        response = ResponseMessage.AUTHORIZATION_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertTrue(clientConnection.isAuthorized());

        // Test operation failed response
        response = ResponseMessage.SWITCH_SUCCEEDED.getResponse();
        clientConnection.checkResponseStatus(response);
        assertFalse(clientConnection.isAuthorized());
        assertTrue(clientConnection.isAdminSwitchedAndAuthorized());
    }
}

====================
FILE: ClientTest.java

package client;

import java.io.BufferedReader;
import java.io.IOException;

import org.junit.jupiter.api.*;
import org.mockito.MockedStatic;
import request.Request;
import request.RequestService;
import shared.Screen;
import shared.UserInteraction;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static shared.Screen.printAdminMailBoxMenu;

class ClientTest {
    Client client;
    static ClientConnection mockConnection;
    BufferedReader mockUserInput;
    UserInteraction mockUserInteraction;
    RequestService mockRequestService;
    Request mockRequestType;

    @BeforeEach
    void setUp() {
        client = new Client();
        mockConnection = mock(ClientConnection.class);
        mockUserInput = mock(BufferedReader.class);
        client.setConnection(mockConnection);
        client.setUserInput(mockUserInput);
        mockUserInteraction = mock(UserInteraction.class);
        mockRequestService = mock(RequestService.class);
        mockRequestType = mock(Request.class);
    }

    @AfterAll
    static void closeDown() {
        mockConnection.disconnect();
    }

    @Test
    @DisplayName("Should test disconnect when user inputs 'EXIT'")
    void testHandleServerCommunication_EXIT() throws IOException {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockUserInput.readLine()).thenReturn("EXIT");

        client.handleServerCommunication();

        // Verify that the client disconnects from the server when "EXIT" is entered
        assertTrue(mockConnection.isConnected());
        assertTrue(mockConnection.isLoggedIn());
        verify(mockConnection, times(1)).disconnect();
    }

    @Test
    @DisplayName("Should test communication handling when admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);
        when(mockConnection.isAuthorized()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> printAdminMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when non-admin user is LOGGED IN")
    void testHandleServerCommunication_LoggedIn_Not_Authorized() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(true);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the mailbox menu is displayed when the user is logged in
        mockScreen.verify(() -> Screen.printUserMailBoxMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT LOGGED IN")
    void testHandleServerCommunication_NotLoggedIn() {
        when(mockConnection.isConnected()).thenReturn(true);
        when(mockConnection.isLoggedIn()).thenReturn(false);

        // Mocking the static methods of the Screen class
        MockedStatic<Screen> mockScreen = mockStatic(Screen.class);
        client.handleServerCommunication();

        // Verify that the login menu is displayed when the user is not logged in
        mockScreen.verify(() -> Screen.printLoginMenu());
        mockScreen.close();
    }

    @Test
    @DisplayName("Should test communication handling when user is NOT CONNECTED")
    void testHandleServerCommunication_NotConnected() throws IOException {
        when(!mockConnection.isConnected()).thenReturn(false);

        client.handleServerCommunication();

        // Verify that no actions are taken when the client is not connected
        verify(mockConnection, never()).isLoggedIn();
        verify(mockUserInput, never()).readLine();
    }

    @Test
    @DisplayName("Should test request handling")
    void testHandleRequest() throws IOException {
        when(mockUserInput.readLine()).thenReturn("LOGIN");
        when(mockRequestService.getRequest("LOGIN")).thenReturn(mockRequestType);

        client.handleRequest("LOGIN");

        // Verify that the request is handled properly
        verify(mockConnection).sendRequest(anyString());
        verify(mockConnection).readResponse();
    }
}

====================
FILE: AccountUpdateHandlerTest.java

package handler;

import database.DatabaseConnection;
import handler.user.PasswordChangeHandler;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.ResponseMessage;
import user.credential.Admin;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.*;

class AccountUpdateHandlerTest {
    PasswordChangeHandler updateHandler;
    UserManager userManager;

    DatabaseConnection DATABASE;
    DSLContext JOOQ;

    @BeforeEach
    void setUp() {
        updateHandler = new PasswordChangeHandler();
        userManager = new UserManager();
        DATABASE = new DatabaseConnection();
        JOOQ = DSL.using(DATABASE.getConnection());
    }

    @Test
    @DisplayName("Should test getting update response for password change")
    void testGetPasswordChangeResponse() {
        Admin admin = new Admin(DATABASE, JOOQ);

        // Admin login
        userManager.login(admin);
        // Password changing
        String response = updateHandler.getChangePasswordResponse(admin.getUsername(), "newPasswod", userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.OPERATION_SUCCEEDED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test getting update status for user account deletion")
    void testGetUserDeleteResponse() {
        String userName = "exampleUsername";
        String password = "examplePassword";
        Admin admin = new Admin(DATABASE, JOOQ);

        // User register
        userManager.handleRegister(userName, password);
        // Admin login
        userManager.login(admin);
        // User account deletion
        String response = updateHandler.getUserDeleteResponse(userName, userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.OPERATION_SUCCEEDED.getResponse(), response);
    }

    @Test
    @DisplayName("Should test getting update response for user role change")
    void testGetChangeRoleResponse() {
        Admin admin = new Admin(DATABASE, JOOQ);

        // Admin login
        userManager.login(admin);
        // Role changing
        String response = updateHandler.getChangeRoleResponse(admin.getUsername(), User.Role.USER, userManager);

        assertNotEquals(ResponseMessage.AUTHORIZATION_FAILED.getResponse(), response);
        assertNotEquals(ResponseMessage.FAILED_TO_FIND_USER.getResponse(), response);
        assertEquals(ResponseMessage.ROLE_CHANGE_SUCCEEDED.getResponse(), response);
    }
}

====================
FILE: MailBoxTest.java

package mail;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.User;

class MailBoxTest {
    MailBox mailBox;
    User sender;
    User recipient;
    Mail mail;

    @BeforeEach
    void setUp() {
        mailBox = new MailBox();
        sender = new User("exampleSender", "examplePassword", User.Role.USER);
        recipient = new User("exampleRecipient", "examplePassword", User.Role.USER);
        mail = new Mail(sender, recipient, "Example message");
    }

    @Test
    @DisplayName("Should test if unread box is not full when it contains less than 5 messages")
    void testIfUnreadBoxNotFull() {
        recipient.getMailBox().getUnreadBox().add(mail);
        // Test if the unread box is not full when it has ony 1 message
        assertFalse(recipient.getMailBox().ifUnreadBoxFull());
    }

    @Test
    @DisplayName("Should test if unread box is full when it contains 5 messages")
    void testIfUnreadBoxFull() {
        for (int i = 0; i < 5; i++) {
            recipient.getMailBox().getUnreadBox().add(mail);
        }
        // Test if the unread box is full when it has exactly 5 messages
        assertTrue(recipient.getMailBox().ifUnreadBoxFull());
    }

    @Test
    @DisplayName("Should test if unread box is full when it contains more than 5 messages")
    void testIfUnreadBoxOverFull() {
        for (int i = 0; i < 8; i++) {
            recipient.getMailBox().getUnreadBox().add(mail);
        }
        // Test if the unread box is full when it has more than 5 messages
        assertTrue(recipient.getMailBox().ifUnreadBoxFull());
    }
}

====================
FILE: MailServiceTest.java

package mail;

import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.User;
import user.manager.UserManager;

class MailServiceTest {
    User sender;
    User recipient;
    Mail mail;
    MailService mailService;
    MailBox mailBox;

    @BeforeEach
    void setUp() {
        sender = new User("senderName", "examplePassword", User.Role.USER);
        recipient = new User("recipientName", "examplePassword", User.Role.USER);
        mail = new Mail(sender, recipient, "Example message");
        mailService = new MailService();
        mailBox = new MailBox();
        UserManager.currentLoggedInUser = sender;
    }

    @Test
    @DisplayName("Should test mail sending")
    void testSendMail() {
        mailService.sendMail(mail);

        assertTrue(sender.getMailBox().getSentBox().contains(mail));
        assertTrue(recipient.getMailBox().getUnreadBox().contains(mail));
    }

    @Test
    @DisplayName("Should test specific mail list returning")
    void testGetMailsToRead() {
        String requestedMailBox = "UNREAD";

        // Test returning unread mails
        List<Mail> mailList = mailService.getMailsToRead(requestedMailBox);

        assertTrue(mailBox.getUnreadBox().equals(mailList));
    }

    @Test
    @DisplayName("Should test emptying mailbox")
    void testEmptyMailbox() {
        String requestedMailBox = "OPEN";

        // Test emptying the opened mailbox
        mailService.deleteMails(requestedMailBox);

        assertTrue(mailBox.getOpenedBox().isEmpty());
    }

    @Test
    @DisplayName("Should test marking mails as read")
    void testMarkMailsAsRead() {
        String requestedMailBox = "UNREAD";
        List<Mail> mailList = List.of(mail);
        mailBox.setUnreadBox(mailList);

        assertFalse(mailBox.getUnreadBox().isEmpty());
        // Test marking mails as read
        mailService.markMailsAsRead(requestedMailBox);
        assertTrue(mailBox.getSentBox().isEmpty());
    }
}

====================
FILE: RequestServiceTest.java

package request;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import shared.UserInteraction;
import user.credential.User;
import user.manager.UserManager;
import client.ClientConnection;

import static org.junit.jupiter.api.Assertions.*;

class RequestServiceTest {
    RequestService requestService;
    RequestFactory factory;
    UserInteraction userInteraction;
    BufferedReader reader;
    User exampleUser;
    UserManager userManager;
    ClientConnection clientConnection;

    @BeforeEach
    void setUp() {
        exampleUser = new User("exampleName", "examplePassword", User.Role.USER);
        UserManager.currentLoggedInUser = exampleUser;
        clientConnection = new ClientConnection();
        requestService = new RequestService(clientConnection);
        factory = new RequestFactory();
        reader = new BufferedReader(new InputStreamReader(System.in));
        userManager = new UserManager();
        userInteraction = new UserInteraction(reader);
    }

    @Test
    @DisplayName("Should test request creating for logged user")
    void testGetRequest_Client_LoggedIn() throws IOException {
        String request = "REGISTER";
        Request expectedType = factory.createAuthRequest(request,
                exampleUser.getUsername(), "examplePassword");
        ClientConnection.loggedIn = false;

        // Test AuthRequest creating
        Request requestType = requestService.getRequest(request);

        assertNotNull(requestType);
        assertEquals(expectedType.getClass(), requestType.getClass());
    }

    @Test
    @DisplayName("Should test request creating for not logged user")
    void testCreateRequest_Client_LoggedOut() throws IOException {
        String request = "WRITE";
        Request expectedType = factory.createWriteRequest(request,
                "exampleUsername", "exampleMessage");
        ClientConnection.loggedIn = true;

        // Test WriteRequest creating
        Request requestType = requestService.getRequest(request);

        assertNotNull(requestType);
        assertEquals(expectedType.getClass(), requestType.getClass());
    }

    @Test
    @DisplayName("Should test account update request creating for non-admin user")
    void testGetAccountUpdateRequest_Not_Authorized() throws IOException {
        clientConnection.setAuthorized(false);

        // // Test AccountUpdateRequest getting
        Request requestType = requestService.getAccountUpdateRequest();

        assertNull(requestType);
    }
}

====================
FILE: ServerConnectionTest.java

package server;

import java.io.BufferedReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class ServerConnectionTest {
    ServerConnection handler;
    ServerSocket mockServerSocket;
    Socket mockClientSocket;
    BufferedReader mockInFromClient;
    PrintWriter mockOutToClient;

    @BeforeEach
    void setUp() {
        handler = new ServerConnection(5000);
        mockServerSocket = mock(ServerSocket.class);
        mockClientSocket = mock(Socket.class);
        mockInFromClient = mock(BufferedReader.class);
        mockOutToClient = mock(PrintWriter.class);
        handler.setClientSocket(mockClientSocket);
        handler.setServerSocket(mockServerSocket);
        handler.setOutToClient(mockOutToClient);
        handler.setInFromClient(mockInFromClient);
    }

    @AfterEach
    void closeDown()  {
        handler.closeConnections();
    }

    @Test
    @DisplayName("Should test connecting to server")
    void testConnectWithClient() {
        when(mockClientSocket.isConnected()).thenReturn(true);
        handler.startServer();

        // Verify that the client is connected
        assertTrue(mockClientSocket.isConnected());
    }
}

====================
FILE: JsonConverterTest.java

package shared;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class JsonConverterTest {
    @Test
    @DisplayName("Should test message serializing to JSon")
    void testSerializeMessage() {
        String message = "exampleMessage";
        JsonConverter converter = new JsonConverter(message);
        String expectedFormat = "{\"message\":\"exampleMessage\"}\n<<END>>";

        // Test JSON serialization
        String serializedMessage = converter.serializeMessage();

        assertNotNull(serializedMessage);
        assertEquals(serializedMessage, expectedFormat);
    }

    @Test
    @DisplayName("Should test message deserializing from JSon")
    void testDeserializeMessage() {
        String message = "exampleMessage";
        JsonConverter converter = new JsonConverter(message);

        String serializedMessage = converter.serializeMessage();

        // Removing "\n<<END>>" from the end of JSon message
        String jsonWithoutEndTag = serializedMessage.replace("\n<<END>>", "");

        // Test JSON deserialization
        String deserializedMessage = converter.deserializeMessage(jsonWithoutEndTag);

        assertNotNull(deserializedMessage);
        assertEquals(message, deserializedMessage);
    }
}

====================
FILE: AdminTest.java

package user;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.*;

class AdminTest {
    UserManager userManager;

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
    }

    @Test
    @DisplayName("Should test changing user password")
    void testChangePassword() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.handleRegister(username, password);

        // Find the user and change the password
        User user = userManager.getUserByUsername(username);
        userManager.changePassword(user, "newPassword");

        assertNotEquals(user.getPassword(), password);
        assertEquals(user.getPassword(), "newPassword");
    }

    @Test
    @DisplayName("should test deleting user")
    void testDeleteUser() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.handleRegister(username, password);

        // Find the user and delete
        User user = userManager.getUserByUsername(username);
        userManager.deleteUser(user);

        assertNull(userManager.getUserByUsername(username));
    }

    @Test
    @DisplayName("should test user role changing")
    void testChangeUserRole() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.handleRegister(username, password);

        // Find the user change the role
        User user = userManager.getUserByUsername(username);
        userManager.changeUserRole(user, User.Role.ADMIN);

        userManager.login(user);
        assertTrue(userManager.isUserAdmin());

    }

    @Test
    @DisplayName("should test user switching")
    void testSwitchUser() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register user
        userManager.handleRegister(username, password);

        // Find the user change the role
        User user = userManager.getUserByUsername(username);
        userManager.switchUser(user);

        assertTrue(UserManager.currentLoggedInUser.equals(user));
        assertTrue(UserManager.ifAdminSwitched);
    }
}

====================
FILE: UserMangerTest.java

package user;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.Admin;
import user.credential.User;
import user.manager.UserManager;

import static org.junit.jupiter.api.Assertions.*;

class UserMangerTest {
    UserManager userManager;

    @BeforeEach
    void setUp() {
        userManager = new UserManager();
    }
    @Test
    @DisplayName("Should test user registration for the first time")
    void testRegister() {
        String userName = "exampleUsername";
        String password = "examplePassword";
        User newUser = new User(userName, password, User.Role.USER);

        // Test user registration with a new username
        userManager.handleRegister(userName, password);
        assertEquals(UserManager.currentLoggedInUser.getUsername(), userName);
        assertEquals(UserManager.currentLoggedInUser.getPassword(), password);
        assertEquals(UserManager.currentLoggedInUser.role, User.Role.USER);
    }

    @Test
    @DisplayName("Should test user registration with existing username")
    void testRegisterExistingUser() {
        String userName = "exampleUsername";
        String password = "examplePassword";

        // Register the user for the first time
        userManager.handleRegister(userName, password);

        // Attempt to register the same user again
        userManager.handleRegister(userName, password);
        String registrationStatus = userManager.registerAndGetResponse(userName, password);

        assertEquals("Registration failed: User already exists", registrationStatus);
    }

    @Test
    @DisplayName("Should test user login with correct credentials")
    void testLoginCorrect() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User newUser = new User(username, password, User.Role.USER);

        // Register the user first
        userManager.handleRegister(username, password);

        // Attempt to log in with correct credentials
        userManager.login(newUser);


        assertNotNull(UserManager.currentLoggedInUser);
        assertEquals(username, UserManager.currentLoggedInUser.getUsername());
        assertEquals(password, UserManager.currentLoggedInUser.getPassword());
    }

    @Test
    @DisplayName("Should test user login with incorrect credentials")
    void testLoginIncorrect() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User anotherUser = new User(username,"wrongPassword" , User.Role.USER);

        // Register the user first
        userManager.handleRegister(username, password);

        // Attempt to log in with incorrect password
        userManager.login(anotherUser);
        String loginStatus = userManager.loginAndGetResponse(username, "wrongPassword");
        assertEquals("Login failed: Incorrect password", loginStatus);
    }

    @Test
    @DisplayName("Should test user logout")
    void testLogout() {
        String username = "exampleUsername";
        String password = "examplePassword";
        User user = new User(username,password , User.Role.USER);

        // Register and login the user first
        userManager.handleRegister(username, password);
        userManager.login(user);

        // Logout the current user
        userManager.logoutCurrentUser();

        assertNull(UserManager.currentLoggedInUser);
    }

    @Test
    @DisplayName("Should test finding user by username")
    void testFindUserByUsername() {
        String username = "exampleUsername";
        String password = "examplePassword";

        // Register the user first
        userManager.handleRegister(username, password);

        // Find the user by username
        User foundUser = userManager.getUserByUsername(username);

        assertNotNull(foundUser);
        assertEquals(username, foundUser.getUsername());
    }

    @Test
    @DisplayName("Should test if current user is admin")
    void testIfCurrentUserAdmin() {
        User admin = new Admin(userManager.DATABASE, userManager.CREATE);

        // Log in as the admin user
        userManager.login(admin);

        assertTrue(userManager.isUserAdmin());
    }
}

====================
FILE: UserTest.java

package user;

import database.DatabaseConnection;
import org.jooq.DSLContext;
import org.jooq.impl.DSL;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import user.credential.User;

import static org.junit.jupiter.api.Assertions.*;

class UserTest {

    DatabaseConnection DATABASE;
    DSLContext JOOQ;

    @BeforeEach
    void setUp() {
        DATABASE = new DatabaseConnection();
        JOOQ = DSL.using(DATABASE.getConnection());
    }

    @Test
    @DisplayName("Should test password matching functionality with correct password")
    void testCheckPasswordCorrect() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "examplePassword";

        boolean isMatching =  user.checkPassword(typedPassword, JOOQ );

        assertTrue(isMatching);
    }

    @Test
    @DisplayName("Should test password matching functionality with incorrect password")
    void testCheckPasswordIncorrect() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "incorrectPassword";

        boolean isMatching =  user.checkPassword(typedPassword, JOOQ);

        assertFalse(isMatching);
    }

    @Test
    @DisplayName("Should test password hashing functionality")
    void testHashPassword() {
        User user = new User("exampleUser", "examplePassword", User.Role.USER);
        String typedPassword = "examplePassword";

        user.hashPassword();

        assertNotNull(user.getHashedPassword());
        assertTrue(user.checkPassword(typedPassword, JOOQ));
    }
}

